[[plugins]]
repo =  'Shougo/denite.nvim'
on_cmd = ['Denite','DeniteBufferDir','DeniteCursorWord','DeniteProjectDir']
on_source = 'defx.nvim'
hook_add = '''
"{{{
nmap <TAB> [denite]
nnoremap [denite] <Nop>

nnoremap <silent> [denite]s :<C-u>DeniteBufferDir
    \  source<CR>

"現在開いているファイルのディレクトリ下のファイル一覧。
nnoremap <silent> [denite]f :<C-u>DeniteBufferDir
    \  file file:new<CR>

"現在開いているファイルのディレクトリ下のファイル一覧。
nnoremap <silent> [denite]F :<C-u>DeniteBufferDir
    \  file/rec file:new<CR>

"ホームディレクトリ下のファイル一覧。
nnoremap <silent> [denite]t :<C-u>DeniteProjectDir
  	\ file file:new<CR>

"ホームディレクトリ下のファイル一覧。
nnoremap <silent> [denite]T :<C-u>DeniteProjectDir
  	\ file/rec file:new<CR>

"バッファ一覧
nnoremap <silent> [denite]b :<C-u>Denite
  	\ -buffer-name=normal 
  	\ buffer<CR>

""デナイト・サーチ
"nnoremap <silent> ? :<C-u>Denite
"  	\ -buffer-name=search
"    \ -start-filter
"    \ -auto-action='highlight'
"  	\ line<CR>

nnoremap <silent> [denite]/ :<C-u>Denite
    \ -buffer-name=search
    \ -auto-action='highlight'
    \ anzu<CR>

"デナイト・キーワードサーチ
"nnoremap <silent> * :<C-u>DeniteCursorWord
"  	\ -buffer-name=search
"  	\ -auto-highlight  line<CR>

"neoyank
nnoremap <silent> [denite]y :<C-u>Denite
    \ -buffer-name=search
    \ neoyank<CR>

nnoremap <silent> [denite]r :<C-u>Denite
    \ -buffer-name=search
    \ register<CR>

"コマンド履歴
nnoremap <silent> [denite]c :<C-u>Denite
    \ -buffer-name=normal
    \ -start-filter
    \ -default-action='execute'
    \ command_history<CR>

"バッファディレクトリからgrep
nnoremap <silent> [denite]g :<C-u>DeniteBufferDir
    \ -buffer-name=search
    \ -no-empty  grep<CR>

"メニュー
nnoremap <silent> [denite]u :<C-u>Denite
    \ -buffer_name=normal
  	\ -winheight=5
    \ menu<CR>

"ヘルプ
nnoremap <silent> [denite]h :<C-u>Denite
    \ -buffer-name=search
    \ -start-filter
    \ help<CR>

"最近使用したファイル-neomru
nnoremap <silent> [denite]n :<C-u>Denite
    \ -buffer-name=normal
    \ file_mru<CR>

"mark一覧
nnoremap <silent> [denite]m :<C-u>Denite
    \ -buffer-name=normal
    \ mark<CR>

":change
nnoremap <silent> [denite]k :<C-u>Denite  change jump<CR>

"searchバッファをresumeして開く
nnoremap <silent><C-n> :<C-u>Denite -buffer-name=search
    \ -resume  -refresh<CR>

"open ale message
nnoremap <silent> [denite]a :<C-u>Denite
	\ -buffer-name=search 
	\ ale<CR>

nnoremap <silent><Leader>n :<C-u>Denite
    \ -cursor-pos=+1 -immediately
    \ -buffer-name=search -no-empty
    \ -resume  -refresh<CR>

"コマンド結果をdeniteに出力
nnoremap [denite]o :<C-u>Denite
    \ -buffer-name=search
    \ output:

nnoremap <silent> [denite]d :<C-u>Denite
    \ -buffer-name=normal
    \ dirmark<CR>

"bookmark by "add"action
nnoremap <silent> [denite]D :<C-u>DeniteBufferDir
    \ -buffer-name=normal
    \ dirmark/add<CR>
autocmd vimrc FileType denite hi link CursorLine ColorColumn
"}}}
'''
hook_source = '''
"{{{
call denite#custom#option('_', {
	\ 'winheight': 14,
    \ 'short_source_names': v:true,
    \ 'highlight_mode_normal': 'Visual',
    \ 'highlight_mode_insert': 'Visual',
    \ 'prompt': '$',
    \ 'highlight_matched_char' : 'Title',
    \ 'max_dynamic_update_candidates' : '50000',
    \ 'direction': 'dynamicbottom',
    \ 'filter_split_direction' : '',
    \ 'vertical_preview': v:true,
    \ 'quick_move_table': {
        \   'a' : 0, 's' : 1, 'd' : 2, 'f' : 3, 'g' : 4,
        \   'h' : 5, 'l' : 6, ';' : 7,
        \   'q' : 8, 'w' : 9, 'e' : 10, 'r' : 11, 't' : 12,
        \ }
	\ })
if has('nvim')
""    call denite#custom#option('_', {
"        \ 'split': 'floating',
"        \ 'wincol': &columns/3,
"        \ 'winwidth': &columns - 10
"        \ })
    call denite#custom#option('_', {
        \ 'split': 'horizontal',
        \ 'statusline' : v:false,
        \ 'filter_split_direction' : ''
        \ })
else
    call denite#custom#option('_', {'statusline': v:false } )
endif
"buffer-normal
call denite#custom#option('normal', {
	\ 'winheight': 10
    \})
"buffer-search
call denite#custom#option('search', {
    \ 'winheight': 10
    \ })

"sorter定義
function! ToggleSorter(sorter) abort
   let sorters = split(b:denite_context.sorters, ',')
   let idx = index(sorters, a:sorter)
   if idx < 0
       call add(sorters, a:sorter)
   else
       call remove(sorters, idx)
   endif
   let b:denite_new_context = {}
   let b:denite_new_context.sorters = join(sorters, ',')
   return '<denite:nop>'
endfunction

"call denite#custom#map('insert', '<C-f>',
"    \ 'ToggleSorter("sorter/reverse")', 'noremap expr nowait')

""need rg for grep/file-rec
call denite#custom#var('file/rec', 'command',
      \ ['rg', '--files', '--no-messages', 
      \ '-g', '!.git', '-g', '!*.tmp', '-g', '!AppData/**'])
call denite#custom#var('grep', 'command', ['rg', '--threads', '1'])
call denite#custom#var('grep', 'recursive_opts', [])
call denite#custom#var('grep', 'final_opts', [])
call denite#custom#var('grep', 'separator', ['--'])
call denite#custom#var('grep', 'default_opts',
      \ ['--vimgrep', '--no-heading'])

" Change matchers.
"call denite#custom#source(
	"\ 'file_mru', 'matchers', ['matcher/regexp', 'matcher/project_files'])
"call denite#custom#source(
"	\ 'file/rec', 'matchers', ['matcher/cpsm'])

" Add custom menus
let s:menus = {
    \ }
let s:menus.window_size = {'description': 'Change window size' }
let s:menus.window_size.command_candidates = [
	\ ['120x60', 'set lines=60 columns=120'],
	\ ['150x40', 'set lines=40 columns=150'],
	\ ['240x40', 'set lines=40 columns=240'],
	\ ['240x60', 'set lines=60 columns=240']
	\ ]
let s:menus.string = {'description': 'string utilities.'}
let s:menus.string.command_candidates = [
      \ ['format: reverse lines', 'g/^/m0'],
      \ ['format: remove ^M', '%s///g'],
      \ ['format: querystring', 'silent! %s/&amp;/\&/g | silent! %s/&/\r&/g | silent! %s/=/\r=/g'],
      \ ['format: to smb', 'silent! %s/\\/\//g | silent! %s/^\(smb:\/\/\|\/\/\)\?/smb:\/\//g']
      \ ]
"let s:menus.vim = {'description': 'vim runtime.'}
"let s:menus.vim.command_candidates = [
"      \ ['upgrade: dein:deps', 'call dein#update()']
"      \ ]

call denite#custom#var('menu', 'menus', s:menus)

"call denite#custom#var('file/rec', 'command',
"      \ ['ack', '-f','-r'])
" Ack command on grep source
"	call denite#custom#var('grep', 'command', ['ack'])
"	call denite#custom#var('grep', 'default_opts',
"			\ ['--ackrc', $HOME.'/.ackrc', '-H', '-i', '-Q',
"			\  '--nopager', '--nocolor', '--nogroup', '--column'])
"	call denite#custom#var('grep', 'recursive_opts', [])
"	call denite#custom#var('grep', 'pattern_opt', ['--match'])
"	call denite#custom#var('grep', 'separator', ['--'])
"	call denite#custom#var('grep', 'final_opts', [])

" Define alias
call denite#custom#alias('source', 'file/rec/git', 'file/rec')
call denite#custom#var('file/rec/git', 'command',
	\ ['git', 'ls-files', '-co', '--exclude-standard'])
"call denite#custom#alias('source', 'file/rec/py', 'file/rec')
"call denite#custom#var('file/rec/py', 'command',['scantree.py'])
" Change ignore_globs
call denite#custom#filter('matcher/ignore_globs', 'ignore_globs',
	\ [ '.git/', '.ropeproject/', '__pycache__/',
	\   'venv/', 'images/','img/', 'fonts/'])

function! s:denite_rec(context)
    let path = a:context['targets'][0]['action__path']
    let dir = denite#util#path2directory(path)
    let sdir = '\"' . dir . '\"'
    execute('Denite file/rec:' . sdir)
endfunction

call denite#custom#action(
    \ 'buffer,directory,file,openable,dirmark', 'file/rec',
    \ function('s:denite_rec')
    \ )

"Defxで開く
function! s:defx_open(context)
    let path = a:context['targets'][0]['action__path']
    let file = fnamemodify(path, ':p')
    let file_search = filereadable(expand(file)) ? ' -search=' . file : ''
    let dir = denite#util#path2directory(path)
    if &filetype ==# 'defx'
      call defx#call_action('cd', [dir])
      call defx#call_action('search', [path])
    else
      execute('Defx ' . dir . file_search)
    endif
endfunction

"action:defxを定義
call denite#custom#action(
    \ 'directory,file,openable,dirmark',
    \ 'defx',
    \  function('s:defx_open'))

autocmd FileType denite-filter call s:denite_my_settings()
function! s:denite_my_settings() abort
  inoremap <silent><buffer><expr> <C-l>
  \ denite#do_map('do_action')
  imap <buffer> <C-[>
  \ <Plug>(denite_filter_quit)
"  inoremap <silent><buffer><expr> <TAB>
"  \ denite#do_map('choose_action')
  inoremap <silent><buffer> <C-j>   <Esc><C-w>p:call cursor(line('.')+1,0)<CR><C-w>pA
  inoremap <silent><buffer> <C-k>   <Esc><C-w>p:call cursor(line('.')-1,0)<CR><C-w>pA
endfunction
"}}}
'''

[plugins.ftplugin]
denite = '''
setlocal signcolumn=yes

nnoremap <silent><buffer><expr> j
\ line('.') == line('$') ? 'gg' : 'j'
nnoremap <silent><buffer><expr> k
\ line('.') == 1 ? 'G' : 'k'
nnoremap <silent><buffer><expr> <TAB>
    \ denite#do_map('choose_action')
nnoremap <silent><buffer><expr> <CR>
    \ denite#do_map('do_action')
nnoremap <silent><buffer><expr> h
    \ denite#do_map('move_up_path')
nnoremap <silent><buffer><expr> d
    \ denite#do_map('do_action', 'delete')
nnoremap <silent><buffer><expr> l
    \ denite#do_map('do_action')
nnoremap <silent><buffer><expr> p
    \ denite#do_map('do_action', 'preview')
nnoremap <silent><buffer><expr> q
    \ denite#do_map('quit')
nnoremap <silent><buffer><expr> i
    \ denite#do_map('open_filter_buffer')
nnoremap <silent><buffer><expr> w
    \ denite#do_map('toggle_select').'j'
nnoremap <silent><buffer><expr> <C-r>
    \ denite#do_map('do_action','file/rec')
'''

[[plugins]]
repo =  'Shougo/neoyank.vim'
on_event = 'TextYankPost'
on_source = ['denite.nvim']

[[plugins]]
repo =  'Shougo/unite.vim'
on_cmd = ['Unite']
on_source = 'TweetVim'

[[plugins]]
repo = 'glidenote/memolist.vim'
on_cmd = ['MemoNew', 'MemoGrep' , 'MemoList']
hook_add = '''
nnoremap <Leader>mn  :MemoNew<CR>
nnoremap <silent><Leader>ml  :<C-u>Denite 
    \ -buffer-name=normal
    \ file/rec:~/GoogleDrive/memo<CR>
nnoremap <silent><Leader>mg  :<C-u>Denite 
    \ -buffer-name=normal
    \ grep:~/GoogleDrive/memo::<CR>
" use denite (default 0)
let g:memolist_denite = 1
let g:memolist_path = "~/GoogleDrive/memo"
let g:memolist_template_dir_path = "~/GoogleDrive/memo/template"
let g:memolist_memo_suffix = "markdown"
let g:memolist_memo_date = "%Y-%m-%d[%H:%M]"
" categories prompt (default 0)
let g:memolist_prompt_categories = 1
'''

[[plugins]]
repo =  'Shougo/defx.nvim'
on_cmd = 'Defx'
hook_add = '''
"{{{
nmap <C-e> <Plug>(defx)
nmap <Leader>e <Plug>(defxbufferdir)
nnoremap <silent> <Plug>(defx) :<C-u>Defx<CR>
nnoremap <silent> <Plug>(defxbufferdir) :<C-u>Defx `expand('%:p:h')` -search=`expand('%:p')`<CR>

nmap <silent> [denite]x <Plug>(defx):<C-u>Denite
    \ -buffer-name=normal
    \ defx/dirmark<CR>
"}}}
'''
hook_source = '''
"{{{

call defx#custom#option('_', {
    \ 'winwidth': 35,
    \ 'split': 'vertical',
    \ 'direction': 'topleft',
    \ 'columns':'mark:indent:icons:filename',
    \ 'sort': 'TIME',
    \ 'ignored_files': '.*,ntuser*,desktop.ini'
    \ })
"call defx#custom#column('indent', {
"    \ 'indent': ' |'
"    \ })
"call defx#custom#column('filename', {
"      \ 'directory_icon': '',
"      \ 'opened_icon': '',
"      \ 'root_icon': '',
"      \ 'min_width': 45,
"      \ 'max_width': 45,
"      \ })
"call defx#custom#column('mark', {
"      \ 'readonly_icon': '✗',
"      \ 'selected_icon': '✓',
"      \ })

function! s:get_defx_bufferdir(candidate) abort
    if line('.') == 1
        let path_mod  = 'h'
    else
        let path_mod = isdirectory(a:candidate) ? '' : 'h'
    endif
    return fnamemodify(a:candidate,'\":p:' . path_mod . '\"')
endfunction

function! Defx_to_denite_rec(context) abort
        let narrow_dir = '\"' . s:get_defx_bufferdir(a:context.targets[0]) . '\"'
        silent! execute('Denite
        \ -default-action=defx
        \ file/rec:' .  narrow_dir)
endfunction
"}}}
'''
[plugins.ftplugin]
defx = '''
"{{{
setlocal signcolumn=no
" Define mappings
nnoremap <silent><buffer><expr> <CR>
\ defx#do_action('drop')
nnoremap <silent><buffer><expr> c
\ defx#async_action('copy')
nnoremap <silent><buffer><expr> m
\ defx#async_action('move')
nnoremap <silent><buffer><expr> p
\ defx#async_action('paste')
nnoremap <silent><buffer><expr> <C-l>
\ <C-l> <C-w>l 
nnoremap <silent><buffer><expr> l 
\ defx#is_directory() ?
\ defx#do_action('open') :
\ defx#do_action('drop')
nnoremap <silent><buffer><expr> E
\ defx#do_action('open', 'vsplit')
nnoremap <silent><buffer><expr> t
\ defx#do_action('multi', ['toggle_sort','filename','redraw'])
nnoremap <silent><buffer><expr> T
\ defx#do_action('multi', [['toggle_sort','TIME'],'redraw'])
nnoremap <silent><buffer><expr> P
\ defx#do_action('open', 'pedit')
nnoremap <silent><buffer><expr> K
\ defx#do_action('new_directory')
nnoremap <silent><buffer><expr> N
\ defx#do_action('new_file')
"need 'pip install Send2Trash'
nnoremap <silent><buffer><expr> d
\ defx#async_action('remove_trash')
nnoremap <silent><buffer><expr> r
\ defx#do_action('rename')
nnoremap <silent><buffer><expr> x
\ defx#async_action('execute_system')
nnoremap <silent><buffer><expr> f
\ defx#do_action('open_or_close_tree')
nnoremap <silent><buffer><expr> yy
\ defx#do_action('yank_path')
nnoremap <silent><buffer><expr> .
\ defx#do_action('toggle_ignored_files')
nnoremap <silent><buffer><expr> h
\ defx#do_action('cd', ['..'])
nnoremap <silent><buffer><expr> ~
\ defx#do_action('cd')
nnoremap <silent><buffer><expr> q
\ defx#do_action('quit')
nnoremap <silent><buffer><expr> i
\ defx#do_action('toggle_select') . 'j'
nnoremap <silent><buffer><expr> I
\ defx#do_action('clear_select_all')
nnoremap <silent><buffer><expr> *
\ defx#do_action('toggle_select_all')
nnoremap <silent><buffer><expr> j
\ line('.') == line('$') ? 'gg' : 'j'
nnoremap <silent><buffer><expr> k
\ line('.') == 1 ? 'G' : 'k'
nnoremap <silent><buffer><expr> <C-l>
\ defx#do_action('redraw')
nnoremap <silent><buffer><expr> <C-g>
\ defx#do_action('print')
nnoremap <silent><buffer><expr> cd
\ defx#do_action('change_vim_cwd')
nnoremap <silent><buffer><expr> <C-r>
\ defx#do_action('call','Defx_to_denite_rec')

"}}}
'''
[[plugins]]
repo = 'kristijanhusak/defx-icons'
on_source = 'defx.nvim'
hook_source = '''
"{{{
"NerdFont List{{{
"This list is useful for testing and choosing interesting symbols.
"Also it's more consistent with current fonts than codepoints shown in README.
"So, it may worth to add this to the wiki - I've opened issue just to ask is this appropriate. Probably it's better to put it on page with Nerd font loaded.
"
"IEC Power Symbols (23FB-23FE,2B58)
"⏻⏼⏽⏾⭘
"Font Awesome Extension (moved E000-E0A9 → E200-E2A9)
"
"
"
"
"
"Powerline Extra Symbols (E0A0-E0A3 E0B0-E0BF E0C0-E0C8 E0CC-E0CF E0D0-E0D2 E0D4)
"
"Devicons (moved E600-E6C5 → E700-E7C5)
"
"
"
"
"
"Font Awesome (F000-F2E0 with holes)
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"Octicons (2665,26A1, moved F000-F105 with holes → F400-F4A8, moved F27C → F67C)
"♥⚡
"
"
"
"
"
"Pomicons (E000-E00A)
"
"Font Linux (moved F100-F115 with holes → F300-F313)
"
"Seti-UI + Custom (E5FA-E62B)
"
"
"}}}

let g:defx_icons_enable_syntax_highlight = 1
let g:defx_icons_column_length = 2
let g:defx_icons_directory_icon = ''
let g:defx_icons_mark_icon = '*'
let g:defx_icons_parent_icon = ''
let g:defx_icons_default_icon = ''
let g:defx_icons_directory_symlink_icon = ''
" Options below are applicable only when using "tree" feature
let g:defx_icons_root_opened_tree_icon = ''
let g:defx_icons_nested_opened_tree_icon = ''
let g:defx_icons_nested_closed_tree_icon = ''
let s:colors = {
      \ 'brown': '905532',
      \ 'aqua': '3AFFDB',
      \ 'blue': '689FB6',
      \ 'darkBlue': '44788E',
      \ 'purple': '834F79',
      \ 'lightPurple': '834F79',
      \ 'red': 'AE403F',
      \ 'beige': 'F5C06F',
      \ 'yellow': 'F09F17',
      \ 'orange': 'D4843E',
      \ 'darkOrange': 'F16529',
      \ 'pink': 'CB6F6F',
      \ 'salmon': 'EE6E73',
      \ 'green': '8FAA54',
      \ 'lightGreen': '31B53E',
      \ 'white': 'C6C8D1'
      \ }
let g:defx_icons_extensions = {
    \'txt' : { 'icon':'', 'color': s:colors.white},
    \'pdf' : { 'icon':'', 'color': s:colors.red},
    \'docx' : { 'icon':'', 'color': s:colors.blue},
    \'doc' : { 'icon':'', 'color': s:colors.blue},
    \'xlsx' : { 'icon':'', 'color': s:colors.green},
    \'pptx' : { 'icon':'', 'color': s:colors.orange},
    \'ppt' : { 'icon':'', 'color': s:colors.orange}
    \}
"}}}
'''

[[plugins]]
repo = 'Shougo/deol.nvim'
hook_add = '''
nnoremap <Leader>d :Deol -edit -split='vertical'<CR>
'''

[[plugins]]
repo =  'Shougo/deoplete.nvim'
on_if = ''' has('nvim') '''
on_event = 'InsertEnter'
hook_source = '''
"{{{
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ deoplete#manual_complete()
function! s:check_back_space() abort "{{{
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction "}}}
inoremap <silent><expr> <C-n>
    \ pumvisible() ? "\<C-n>" :
    \ deoplete#manual_complete()
" <S-TAB>: completion back.
inoremap <silent><expr><C-g>
    \ deoplete#undo_completion()
inoremap <silent><expr><C-h>
    \ deoplete#smart_close_popup()."\<C-h>"
inoremap <silent><expr><BS>
    \ deoplete#smart_close_popup()."\<C-h>"
inoremap <silent><expr><C-l>       deoplete#complete_common_string()
inoremap <expr><C-l>       deoplete#insert_candidate(0)
"" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function() abort
  return pumvisible() ? deoplete#close_popup() : "\<CR>"
endfunction

"call deoplete#custom#source('_', 'matchers',
"      \ ['matcher_fuzzy', 'matcher_length'])
call deoplete#custom#source('_', 'matchers', ['matcher_fuzzy'])
call deoplete#custom#source('buffer', 'mark', 'b')
call deoplete#custom#source('eskk', 'mark' , 'eskk')
"matcherを指定してはいけない
call deoplete#custom#source('eskk', 'matchers', [])
call deoplete#custom#source('vim', 'rank' , 250)
call deoplete#custom#source('file', 'rank', 1000)
call deoplete#custom#source('vim', 'min_pattern_length', 2)
"
call deoplete#custom#source('_', 'converters', [
    \ 'converter_remove_paren',
    \ 'converter_remove_overlap',
    \ 'converter_truncate_abbr',
    \ 'converter_truncate_menu',
    \ 'converter_auto_paren',
    \ 'converter_auto_delimiter'
    \ ])

" Using custom variables to configure values
" - range_above = Search for words N lines above.
" - range_below = Search for words N lines below.
" - mark_above = Mark shown for words N lines above.
" - mark_below = Mark shown for words N lines below.
" - mark_changes = Mark shown for words in the changelist.
"call deoplete#custom#option('ignore_sources',{'_':['around']})
call deoplete#custom#var('around', {
\   'range_above': 20,
\   'range_below': 20,
\   'mark_above': '[↑]',
\   'mark_below': '[↓]',
\   'mark_changes': '[*]',
\})
call deoplete#custom#option('sources', {
    \ 'denite-filter': ['denite']
    \ })
call deoplete#custom#option({
    \ 'auto_complete_delay': 20,
    \ 'skip_multibyte': v:false,
    \ 'min_pattern_length': 2,
    \ 'prev_completion_mode': 'mirror'
    \ })
call deoplete#enable()

"}}}
'''
[[plugins]]
repo = 'Shougo/neocomplete.vim'
on_if = ''' !has('nvim') '''
on_event = 'InsertEnter'
hook_source = '''
"{{{
let g:neocomplete#enable_smart_case = 1
"let g:neocomplete#enable_auto_select = 1

"vimprocを有効化すると初回の補完がちょっと遅くなる
let g:neocomplete#use_vimproc = 1
let g:neocomplete#min_keyword_length = 2
" Define keyword.
" Plugin key-madeinppings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()
" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return pumvisible() ? "\<C-y>" : "\<CR>"
endfunction
inoremap <silent><expr> <C-n>
    \ pumvisible() ? "\<C-n>" :
    \ neocomplete#start_manual_complete()
" <TAB>: completion.
inoremap <silent><expr> <TAB>
    \ pumvisible() ? "\<C-n>" :
    \ neosnippet#expandable_or_jumpable() ?
    \    "\<Plug>(neosnippet_expand_or_jump)" :
    \ <SID>check_back_space() ? "\<TAB>" :
    \ neocomplete#start_manual_complete()
function! s:check_back_space() abort "{{{
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~ '\s'
endfunction"}}}
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
let g:neocomplete#sources#buffer#cache_limit_size = 500000
let g:neocomplete#auto_complete_delay = 1
let g:neocomplete#skip_auto_completion_time = '0.2'
let g:neocomplete#enable_multibyte_completion = 1

if !exists('g:neocomplete#keyword_patterns')
  let g:neocomplete#keyword_patterns = {}
endif

"let g:neocomplete#keyword_patterns['default'] = '\k\+'
let g:neocomplete#max_list=300
"call neocomplete#custom#source('_', 'matchers', ['matcher_head','matcher_length'])
" Change default converter.
"call neocomplete#custom#source('_', 'converters',
"\ ['converter_remove_overlap', 'converter_remove_last_paren',
"    \  'converter_abbr'])
call neocomplete#custom#source('eskk', 'rank', 500) 
call neocomplete#custom#source('vim', 'rank' , 250)
call neocomplete#custom#source('buffer', 'mark', 'b')
call neocomplete#custom#source('eskk', 'mark' , '▽')
call neocomplete#custom#source('eskk', 'max_menu_width', 80)
let g:neocomplete#ignore_source_files = [
    \'member', 'tag.vim', 'dictionary.vim', 'include.vim', 'file_include.vim'
    \]
call neocomplete#initialize()
"}}}
'''

[[plugins]]
repo =  'Shougo/neco-vim'
on_source = ['deoplete','neocomplete']
on_ft = 'vim'

[[plugins]]
repo = 'mattn/googlesuggest-complete-vim'
on_event = 'InsertEnter'
depends = ['webapi-vim']
hook_add = '''
"set completefunc=googlesuggest#Complete
'''

[[plugins]]
repo =  'Shougo/neosnippet'
depends = ['neosnippet-snippets']
on_event = 'InsertCharPre'
on_ft = 'snippet'
hook_source = '''
"{{{
" Plugin key-mappings.
" Note: It must be "imap" and "smap".  It uses <Plug> mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
" Note: It must be "imap" and "smap".  It uses <Plug> mappings.
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
" For conceal markers.
"if has('conceal')
"  set conceallevel=2
"endif
"}}}
'''

[[plugins]]
repo =  'tyru/eskk.vim'
on_event = ['InsertEnter','CmdlineEnter']
hook_add = '''
"{{{
let g:eskk#debug = 0
let g:eskk#rom_input_style = 'msime'
let g:eskk#egg_like_newline = 1
let g:eskk#egg_like_newline_completion = 1
let g:eskk#tab_select_completion = 1
let g:eskk#start_completion_length = 3
let g:eskk_revert_henkan_style = 'okuri'
let g:eskk#dictionary = {
\	'path': "~/GoogleDrive/rc/.skk-jisyo",
\	'sorted': 0,
\	'encoding': 'utf-8',
\}
let g:eskk#large_dictionary = {'path': '~/.skk/SKK-JISYO.L', 'sorted': 1, 'encoding': 'euc-jp', }
let g:eskk#dictionary_save_count = 5
let g:eskk#cursor_color = {
\   'ascii': '#b4be82',
\   'hira': '#e28878',
\   'kata': '#84a0c6',
\   'abbrev': '#4169e1',
\   'zenei': '#ffd700',
\}
nnoremap <silent><expr><C-y> <SID>eskk_inserttoggle()
imap <C-j> <Plug>(eskk:toggle)
cmap <C-j> <Plug>(eskk:toggle)
"}}}
'''
hook_source = '''
"{{{
augroup myeskk
autocmd!
autocmd InsertLeave * call <SID>eskk_status()
"autocmd InsertLeave * call <SID>normalcolumn()
autocmd InsertEnter * call <SID>eskk_insert_config()
augroup END
 
let s:eskk_insert_status = 0
let s:eskk_inserton = 0
let g:eskk_my_toggle_status = 0

function! s:eskk_status() abort
    let s:eskk_inserton = eskk#is_enabled() ? 1 : 0
    let g:eskk_my_toggle_status = s:eskk_insert_status ? 1 : s:eskk_inserton ? 1 : 0
endfunction

function! s:eskk_insert_config() abort
    if &filetype ==# 'denite-filter'
    else
    if s:eskk_inserton || s:eskk_insert_status 
        call eskk#enable()
    endif
    endif
endfunction

"autocmd InsertEnter * call s:denite_eskk_off()
"function! s:denite_eskk_off() abort
"    if &filetype ==# 'denite-filter'
"        call eskk#disable()
"    endif
"endfunction

function! s:define_LLmyeskk()
    function! LLmyeskk() abort
        if eskk#is_enabled()
            return printf(get(a:000, 0, '[%s]'),
                \ get(g:eskk#statusline_mode_strings,
                \ eskk#get_current_instance().mode, '??'))
        elseif mode() !=# 'i'
            return g:eskk_my_toggle_status ? printf('[あ]') : printf('[--]')
        else
            return printf('[--]')
        endif
    endfunction
endfunction

function! s:eskk_inserttoggle() abort
    if s:eskk_insert_status || s:eskk_inserton
        let s:eskk_insert_status = 0
        let s:eskk_inserton = 0
        let g:eskk_my_toggle_status = 0
        echo 'eskk status off'
    else
        let s:eskk_insert_status = 1
        let g:eskk_my_toggle_status = 1
        echo 'eskk status on'
    endif
endfunction

"IME/skkの状態に応じてsigncolumnの色を変える（WIP）
"SignColumn     xxx ctermfg=239 ctermbg=235 guifg=#444b71 guibg=#1e2132
autocmd vimrc User eskk-enable-post hi CursorLineNr ctermfg=253 ctermbg=237 gui=bold guifg=#e2a478 guibg=#2a3158
"autocmd vimrc CursorMovedI * call s:eskkmodecolumn()
autocmd vimrc User eskk-disable-post hi CursorLineNr ctermfg=253 ctermbg=237 gui=bold guifg=#cdd1e6 guibg=#2a3158

"function! s:eskkmodecolumn() abort
"    let eskk_mode = eskk#get_mode()
"    if !has_key(g:eskk#cursor_color, eskk_mode)
"        return
"    endif
"    
"    let color = g:eskk#cursor_color[eskk_mode]
"    if type(color) == type([]) && len(color) >= 2
"        execute 'highlight CursorLineNr guibg=' . color[&background ==# 'light' ? 0 : 1]
"    elseif type(color) == type("") && color !=# ''
"        execute 'highlight CursorLineNr guibg=' . color
"    endif
"endfunction

function! s:insertcolumn()
    hi CursorLineNr ctermfg=253 ctermbg=237 gui=bold guifg=#84a0c6 guibg=#2a3158
endfunction

function! s:normalcolumn()
    if !g:eskk_my_toggle_status
        hi CursorLineNr ctermfg=253 ctermbg=237 gui=bold guifg=#cdd1e6 guibg=#2a3158
    endif
endfunction

"autocmd vimrc User eskk-initialize-post
"      \ EskkMap -remap ll <C-j>
autocmd vimrc User eskk-initialize-pre call s:eskk_initial_pre() | call <SID>define_LLmyeskk()
function! s:eskk_initial_pre() abort
    let t = eskk#table#new('rom_to_hira*', 'rom_to_hira')
    call t.add_map('z ', '　')
    call t.add_map('~', '〜')
    call t.add_map('zc', '©')
    call t.add_map('zr', '®')
    call t.add_map('z9', '（')
    call t.add_map('z0', '）')
    call t.add_map('z-', '-')
    call t.add_map('z{', '【')
    call t.add_map('z}', '】')
      " "1." のように数字の後のドットはそのまま入力
    for n in range(10)
      call t.add_map(n . '.', n . '.')
    endfor
  call eskk#register_mode_table('hira', t)
endfunction
"}}}
'''

[[plugins]]
repo =  'cohama/lexima.vim'
on_if = 'has("nvim")'
on_event = 'InsertEnter' 
hook_post_source = '''
"{{{
let g:lexima_no_default_rules = 1
call lexima#set_default_rules()
let g:lexima_enable_newline_rules = 1
let g:lexima_enable_endwise_rules = 1
call lexima#add_rule({'char': '「', 'input': '「', 'input_after': '」'})
call lexima#add_rule({'char': '『', 'input': '『', 'input_after': '』'})
call lexima#add_rule({'char': '【', 'input': '【', 'input_after': '】'})
call lexima#add_rule({'char': '（', 'input': '（', 'input_after': '）'})
call lexima#add_rule({'char': '(', 'input': '(', 'input_after':')'})
"call lexima#add_rule({'char': '（', 'input': '（', 'input_after': '）'})
"call lexima#add_rule({'char': '<BS>', 'at': '「', 'input': '<BS>', 'delete' : 1})
"call lexima#add_rule({'char': '<BS>', 'at': '『', 'input': '<BS>', 'delete' : 1})
"call lexima#add_rule({'char': '<BS>', 'at': '【', 'input': '<BS>', 'delete' : 1})
"call lexima#add_rule({'char': '<BS>', 'at': '（', 'input': '<BS>', 'delete' : 1})
"call lexima#add_rule({'char': '(', 'at': '\%#)', 'leave': 1})
"call lexima#add_rule({'char': '"', 'at': '\%#"', 'leave': 1})
"call lexima#add_rule({'char': '[', 'at': '\%#]', 'leave': 1})
"call lexima#add_rule({'char': '{', 'at': '\%#}', 'leave': 1})
"call lexima#add_rule({'char': '『', 'at': '\%#』', 'leave': 1})
"call lexima#add_rule({'char': '「', 'at': '\%#」', 'leave': 1})
"call lexima#add_rule({'char': '（', 'at': '\%#）', 'leave': 1})
"}}}
'''

[[plugins]]
repo = 'kana/vim-operator-replace'
depends = 'vim-operator-user'
on_map = {nv = '<Plug>'}
hook_add = '''
nmap _ <Plug>(operator-replace)
vmap _ <Plug>(operator-replace)
'''

# [[plugins]]
# repo =  'lambdalisue/gina.vim'
# on_cmd = ['Gina']
# hook_add = '''
# nnoremap <Leader>aa :<C-u>Gina status --short<CR>
# nnoremap <Leader>ac :<C-u>Gina commit<CR>
# nnoremap <Leader>ap :<C-u>Gina push<CR>
# '''
# hook_post_source = '''
# "{{{
# call gina#custom#command#alias('branch', 'br')
# call gina#custom#command#option('br', '-v', 'v')
# call gina#custom#command#option(
# \ '/\%(log\|reflog\)',
# \ '--opener', 'vsplit'
# \)

# call gina#custom#command#option(
# \ '/\%(status\|branch\|ls\|grep\|changes\|tag\)',
# \ '--opener' , '10split'
# \)
# call gina#custom#command#option(
# \ 'log', '--group', 'log-viewer'
# \)
# call gina#custom#command#option(
# \ 'status', '--group', 'status-viewer'
# \)
# call gina#custom#command#option(
# \ 'reflog', '--group', 'reflog-viewer'
# \)
# call gina#custom#command#option(
# \ 'commit', '-v|--verbose'
# \)
# call gina#custom#command#option(
# \ '/\%(status\|commit\)',
# \ '-u|--untracked-files'
# \)
# call gina#custom#command#option(
# \ '/\%(status\|changes\)',
# \ '--ignore-submodules'
# \)

# call gina#custom#action#alias(
# \ 'branch', 'track',
# \ 'checkout:track'
# \)
# call gina#custom#action#alias(
# \ 'branch', 'merge',
# \ 'commit:merge'
# \)
# call gina#custom#action#alias(
# \ 'branch', 'rebase',
# \ 'commit:rebase'
# \)

# call gina#custom#mapping#nmap(
# \ 'branch', 'g<CR>',
# \ '<Plug>(gina-commit-checkout-track)'
# \)
# call gina#custom#mapping#nmap(
# \ 'status', '<C-^>',
# \ ':<C-u>Gina commit<CR>',
# \ {'noremap': 1, 'silent': 1}
# \)
# call gina#custom#mapping#nmap(
# \ 'commit', '<C-^>',
# \ ':<C-u>Gina status<CR>',
# \ {'noremap': 1, 'silent': 1}
# \)

# "call gina#custom#execute(
# "\ '/\%(status\|branch\|ls\|grep\|changes\|tag\)',
# "\ 'setlocal winfixheight',
# "\)
# "}}}
# '''

# [[plugins]]
# repo =  'sjl/gundo.vim'
# on_cmd = 'GundoToggle'
# hook_add = '''
# nnoremap U :<C-u>GundoToggle<CR>
# '''
# hook_source = '''
# "{{{
# let g:gundo_help =1 
# let g:gundo_prefer_python3 = 1
# let g:gundo_auto_preview = 0
# let g:gundo_width = 50
# let g:gundo_right = 1
# let g:gundo_preview_height = 20
# let g:gundo_preview_bottom = 0
# let g:gundo_playback_delay = 500
# "}}}
# '''

[[plugins]]
repo =  'nathanaelkane/vim-indent-guides'
on_cmd = 'IndentGuideToggle'
hook_add = '''
nnoremap <silent><Leader>ig :IndentGuidesToggle<CR>
'''
hook_source ='''
let g:indent_guides_exclude_filetypes = ['help', 'defx']
'''

[[plugins]]
repo =  'w0rp/ale'
on_event = 'InsertLeave'
hook_source ='''
"{{{
"https://efcl.info/2015/09/10/introduce-textlint/
"https://koirand.github.io/blog/2018/textlint/
"vint: pip install --pre vim-vint
"preset-ja-technical-writing
"npm install textlint-rule-preset-ja-technical-writing@beta
let g:ale_use_global_executables=1
let g:ale_set_balloons =0
let g:ale_linters = {
    \ 'markdown': ['textlint'],
    \ 'pandoc' : ['textlint'],
    \ 'vim':['vint'],
    \ 'python': ['flake8'],
    \ 'text':['textlint']
    \ }

let g:ale_set_loclist = 0
let g:ale_set_quickfix = 0
let g:ale_sign_column_always = 1
let g:ale_lint_delay = 5000
let g:ale_lint_on_enter = 0
let g:ale_lint_on_text_changed = 0
let g:ale_lint_on_filetype_changed = 0
let g:ale_open_list = 0
let g:ale_keep_list_window_open = 0
let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
if has('mac')
    let g:ale_sign_error = ''
    let g:ale_sign_warning = ''
    let g:ale_statusline_format = ['%d', '%d', '']
else
    let g:ale_sign_error = ''
    let g:ale_sign_warning = ''
    let g:ale_statusline_format = ['%d', '%d', '']
endif
"}}}
'''

[[plugins]]
repo =  'maximbaz/lightline-ale'
on_source = 'ale'
depends = ['lightline.vim']
hook_add = '''
if has('mac')
    let g:lightline#ale#indicator_checking = "\uf110"
    let g:lightline#ale#indicator_warnings = ''
    let g:lightline#ale#indicator_errors = ''
    let g:lightline#ale#indicator_ok = ""
else
    let g:lightline#ale#indicator_checking = "\uf110"
    let g:lightline#ale#indicator_warnings = "\uf48f"
    let g:lightline#ale#indicator_errors = "\uf484"
    let g:lightline#ale#indicator_ok = "\uf43a"
endif
'''

[[plugins]]
repo =  't9md/vim-choosewin'
on_map = {n = '<Plug>'}
hook_add = '''
nmap - <Plug>(choosewin)

let s:keymap = {
      \ '0':     'tab_first',
      \ '[':     'tab_prev',
      \ ']':     'tab_next',
      \ '$':     'tab_last',
      \ 'x':     'tab_close',
      \ ';':     'win_land',
      \ '-':     'previous',
      \ 's':     'swap',
      \ 'S':     'swap_stay',
      \ "\<CR>": 'win_land',
      \ }
let g:choosewin_keymap = s:keymap
'''
hook_source = '''
let g:choosewin_blink_on_land = 0
let g:choosewin_label = 'ASDFGHJKL'
'''

[[plugins]]
repo =  'basyura/TweetVim'
on_cmd = ['TweetVimHomeTimeline', 'TweetVimSay']
depends = ['twibill.vim', 'webapi-vim']
hook_add = '''
"{{{
nnoremap <silent> <Leader>ts  :<C-u>TweetVimSay<CR>
nnoremap <silent> <Leader>tt  :TweetVimHomeTimeline<CR>
nnoremap <silent> <Leader>tm :TweetVimMentions<CR>
nnoremap <silent><Leader>tu :<C-u>Denite -buffer-name=normal unite:tweetvim<CR>
"}}}
'''

hook_source = '''
"{{{
autocmd vimrc FileType tweetvim setlocal nonumber
if !executable('convert') || has('nvim')
    autocmd vimrc FileType tweetvim setlocal signcolumn=no
endif

let g:tweetvim_tweet_per_page = 60
let g:tweetvim_include_rts    = 1
let g:tweetvim_config_dir = expand('~/vimfiles/.tweetvim')
let g:tweetvim_open_buffer_cmd = 'botright 44vsplit'
let g:tweetvim_display_separator = 1
let g:tweetvim_empty_separator = 1
let g:tweetvim_display_time = 1
let g:tweetvim_display_username = 1
let g:tweetvim_tweet_limit = 560
let g:tweetvim_display_icon = 1

if !has('nvim')
    let g:tweetvim_async_post = 1
endif

function! s:tw_open_existing() abort
  let bnr = bufnr('[tweetvim]')
  if bnr == -1
    echoerr 'call TweetVim!:'
    return
  endif
  let wids = win_findbuf(bnr)
    call win_gotoid(wids[0])
endfunction

highlight tweetvim_screen_name term = bold ctermfg=33 guifg=#4078f2
highlight tweetvim_at_screen_name term = bold ctermfg=33 guifg=#4078f2
" 自動更新間隔（秒）
"https://gist.github.com/rhysd/4201877
let s:tweetvim_update_interval_seconds = 60
let s:tweetvim_timestamp = reltime()[0]
function! s:tweetvim_autoupdate()
    let current = reltime()[0]
    if current - s:tweetvim_timestamp > s:tweetvim_update_interval_seconds
        call feedkeys("\<Plug>(tweetvim_action_reload)")
        let s:tweetvim_timestamp = current
    endif
    call feedkeys(mode() ==# 'i' ? "\<C-g>\<ESC>" : "g\<ESC>", 'n')
endfunction

function! s:tweetvim_setup_autoupdate()
    augroup vimrc-tweetvim-autoupdate
        autocmd!
        autocmd CursorHold * call <SID>tweetvim_autoupdate()
    augroup END
endfunction

" 自動更新開始と終了用コマンド
command! -nargs=0 TweetVimAutoUpdate call <SID>tweetvim_setup_autoupdate()
command! -nargs=0 TweetVimStopAutoUpdate autocmd! vimrc-tweetvim-autoupdate

autocmd vimrc ColorScheme * highlight tweetvim_screen_name term = bold ctermfg=33 guifg=#4078f2
autocmd vimrc ColorScheme * highlight tweetvim_at_screen_name term = bold ctermfg=33 guifg=#4078f2
"}}}
'''
[plugins.ftplugin]
tweetvim_say = '''
"{{{
" マッピング
" 挿入・通常モードでsayバッファを閉じる
nnoremap <buffer><silent><C-g>    :<C-u>q!<CR>
inoremap <buffer><silent><C-g>    <C-o>:<C-u>q!<CR><Esc>
"}}}
'''

[plugins.ftplugin]
tweetvim = '''
"{{{
"各種アクション
nnoremap <buffer>S          :<C-u>TweetVimSay<CR>
nnoremap <buffer>m          :<C-u>TweetVimMentions<CR>
nnoremap <buffer>dd :Denite -buffer-name=normal -direction='dynamicbottom' unite:tweetvim<CR>
nnoremap <buffer>j          }j
nnoremap <buffer>k          k{j
nnoremap <buffer>th         :TweetVimHomeTimeline<CR>
nnoremap <buffer>r          :redraw<CR>
nmap     <buffer>c          <Plug>(tweetvim_action_in_reply_to)
nmap     <buffer><Leader>F  <Plug>(tweetvim_action_remove_favorite)
nmap     <buffer><Leader>d  <Plug>(tweetvim_action_remove_status)
nmap     <buffer>o          <Plug>(tweetvim_action_open_links)
nmap     <silent><buffer>q  :bd<CR>
nmap     <buffer><Tab>      <Plug>(tweetvim_action_reload)
"ページの先頭に戻ったときにリロード
nmap     <buffer><silent>gg gg<Plug>(tweetvim_action_reload)
"ページ移動をff/bb から f/b に
nmap     <buffer>f          <Plug>(tweetvim_action_page_next)
nmap     <buffer>b          <Plug>(tweetvim_action_page_previous)
nnoremap <silent> <buffer>n <C-d>
nnoremap <silent> <buffer>p <C-u>
"不要なマップを除去
nunmap   <buffer>ff
nunmap   <buffer>bb
" tweetvim バッファに移動したときに自動リロード
"autocmd BufEnter * call <SID>tweetvim_reload()
" filetype が tweetvim ならツイートをリロード
"function! s:tweetvim_reload()
"    if &filetype ==# 'tweetvim'
"        call feedkeys("\<Plug>(tweetvim_action_reload)")
"    endif
"endfunction
"}}}
'''

[[plugins]]
repo = 'previm/previm'
depends = 'open-browser.vim'
on_ft = ['markdown','md']
hook_add = '''
let g:previm_open_cmd = 'open -a Safari'
nnoremap <silent><Leader>pmd :PrevimOpen<CR>
'''

[[plugins]]
repo =  'rhysd/vim-operator-surround'
depends = 'vim-operator-user'
on_map = {nv= '<Plug>'}
hook_add = '''
map <silent>'a <Plug>(operator-surround-append)
map <silent>'d <Plug>(operator-surround-delete)
map <silent>'r <Plug>(operator-surround-replace)
'''
hook_source = '''
"2バイト括弧を追加
let g:operator#surround#blocks = {}
let g:operator#surround#blocks['-'] = [
\   { 'block' : ['（', '）'], 'motionwise' : ['char', 'line', 'block'], 'keys' : ['P'] },
\   { 'block' : ['「', '」'], 'motionwise' : ['char', 'line', 'block'], 'keys' : ['K'] },
\   { 'block' : ['『', '』'], 'motionwise' : ['char', 'line', 'block'], 'keys' : ['D'] },
\ ]
'''

[[plugins]]
repo = 'itchyny/vim-cursorword'
on_map = {nv='<Plug>'}
hook_add = '''
let g:cursorword = 0
function! s:toggle_vim_cursorword() abort
  let g:cursorword = g:cursorword ? 0 : 1
  call cursorword#matchadd()
endfunction
nnoremap <silent> <Plug>(cursorword-toggle)
      \ :<C-u>call <SID>toggle_vim_cursorword()<CR>
nmap <C-g>c     <Plug>(cursorword-toggle)
nmap <C-g><C-c> <Plug>(cursorword-toggle)
'''

[[plugins]]
repo = 'osyo-manga/vim-precious'
on_ft = 'toml'
hook_source = '''
" カーソル移動時の自動切り替えを無効化
" このオプションは filetype ごとに設定可能
" "*" は全ての filetype に影響する
let g:precious_enable_switch_CursorMoved = {
\   "*" : 0
\}
let g:precious_enable_switch_CursorMoved_i = {
\   "*" : 0
\}

" insert に入った時にスイッチし、抜けた時に元に戻す
augroup test
    autocmd!
    autocmd InsertEnter * :PreciousSwitch
    autocmd InsertLeave * :PreciousReset
augroup END
'''
[[plugins]]
repo = 'mattn/benchvimrc-vim'
on_cmd = 'BenchVimrc'

[[plugins]]
repo = 'junegunn/goyo.vim'
on_cmd = 'Goyo'
hook_add = '''
nnoremap <F4> :Goyo<CR>
let g:goyo_width = 80
let g:goyo_height = '60%'
function! s:goyo_enter()
  set scrolloff=999
  Limelight
endfunction

function! s:goyo_leave()
  set scrolloff=3
  Limelight!
endfunction

autocmd! User GoyoEnter nested call <SID>goyo_enter()
autocmd! User GoyoLeave nested call <SID>goyo_leave()

'''
[[plugins]]
repo = 'junegunn/limelight.vim'
on_cmd = 'Limelight'

[[plugins]]
repo = 'junegunn/vim-easy-align'
on_map = '<Plug>(EasyAlign)'
hook_add = '''
vmap ga <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)
'''
[[plugins]]
repo = 'soramugi/auto-ctags.vim'
on_cmd = ['Ctags']
hook_add = '''
let g:auto_ctags_tags_name = 'tags'
let g:auto_ctags_tags_args = ['--tag-relative=yes', '--recurse=yes', '--sort=yes']
let g:auto_ctags_filetype_mode = 1
'''

[[plugins]]
repo =  'tyru/open-browser.vim'
on_map = {nx = '<Plug>(openbrowser-'}
hook_add ='''
nmap <Leader>o <Plug>(openbrowser-smart-search)
vmap <Leader>o <Plug>(openbrowser-smart-search)
'''

[[plugins]]
repo = 'haya14busa/vim-migemo'
on_map = {n = '<Plug>'}
hook_add = '''
nmap <Leader>m <Plug>(migemo-searchchar)
'''
hook_source = '''
nnoremap / g/
nnoremap g/ /
'''

[[plugins]]
repo = 'easymotion/vim-easymotion'
on_map = {nx = '<Plug>'}
hook_add = '''
let g:EasyMotion_do_mapping = 0
nmap s <Plug>(easymotion-s2)
imap <C-Space> <ESC><Plug>(easymotion-s2)
xmap s <Plug>(easymotion-s2)
omap s <Plug>(easymotion-s2)
" Jump to first match with enter & space
let g:EasyMotion_use_upper = 1
let g:EasyMotion_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ;'
let g:EasyMotion_smartcase = 1
let g:EasyMotion_enter_jump_first = 1
let g:EasyMotion_space_jump_first = 1
let g:EasyMotion_use_migemo = 1
'''

[[plugins]]
repo = 'haya14busa/vim-asterisk'
depends = 'is.vim'
on_map = {nx = '<Plug>'}
hook_add = '''
let g:asterisk#keeppos = 1
map *  <Plug>(asterisk-z*)<Plug>(is-nohl-1)
map g* <Plug>(asterisk-gz*)<Plug>(is-nohl-1)
map #  <Plug>(asterisk-z#)<Plug>(is-nohl-1)
map g# <Plug>(asterisk-gz#)<Plug>(is-nohl-1)
'''

#[[plugins]]
#on_ft = ['markdown','md']
#repo ='plasticboy/vim-markdown'
#hook_add = '''
#let g:vim_markdown_no_default_key_mappings = 1
#let g:vim_markdown_new_list_item_indent = 4
#let g:vim_markdown_foldint_level = 0
#'''

[[plugins]]
repo = 'davidhalter/jedi-vim'
on_ft = ['python']
hook_add = '''
let g:jedi#auto_vim_configuration = 0
'''

[[plugins]]
repo = 'thinca/vim-quickrun'
on_cmd = ['QuickRun']
hook_add = '''
let g:quickrun_config = {
        \ '_' : {
        \ 'outputter/buffer/append' : 1
        \ },
        \ 'python': {
        \ 'command': 'python3'
        \ }
    \ }
'''

[[plugins]]
repo = 'mbbill/undotree'
on_cmd = ['UndotreeToggle']
hook_add = '''
let g:undotree_SetFocusWhenToggle = 1
'''

[[plugins]]
repo = 'majutsushi/tagbar'
on_cmd = ['Tagbar']

# vim:set foldmethod=marker:
