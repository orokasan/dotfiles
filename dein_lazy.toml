[[plugins]]
# repo =  'Shougo/denite.nvim'
repo =  'orokasan/denite.nvim'
on_cmd = ['Denite','DeniteBufferDir','DeniteCursorWord','DeniteProjectDir']
hook_add = ''' "{{{
nmap s [denite]
nnoremap [denite] <Nop>

nnoremap <silent> [denite]- :<C-u>DeniteBufferDir
    \ -start-filter
    \  source<CR>

"現在開いているファイルのディレクトリ下のファイル一覧。
nnoremap <silent> [denite]s :<C-u>Denite
    \ -start-filter
    \ -path=`<SID>denite_gitdir()`
    \  file/rec file:new<CR>

function! s:denite_gitdir() abort
if finddir('.git', '.;') != ''
    let path = (empty(bufname('%')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|terminal\)$') ? getcwd() : expand('%:p')
    let dir = finddir('.git', path.';')
    if empty(dir) | return '' | endif
    let files = findfile('.git', path.';',-1)
    if empty(files) | return fnamemodify(dir, ':p:h:h') | endif
    let path = fnamemodify(files[-1], ':p:h')
else
    let path = expand('%:p:h')
return path
endfunction

nnoremap <silent> [denite]S :<C-u>DeniteBufferDir
    \ -start-filter
    \  file/rec file:new<CR>

nnoremap <silent> [denite]f :<C-u>DeniteProjectDir
    \ -start-filter
    \  file/rec file:new<CR>

"現在開いているファイルのディレクトリ下のファイル一覧。
nnoremap <silent> [denite]F :<C-u>DeniteProjectDir
    \ -start-filter
    \  file file:new<CR>

"ホームディレクトリ下のファイル一覧。
nnoremap <silent> [denite]t :<C-u>Denite
    \ -start-filter
    \ -path=$HOME
    \ file/rec file:new<CR>

"ホームディレクトリ下のファイル一覧。
nnoremap <silent> [denite]T :<C-u>Denite
    \ -start-filter
    \ -path=$HOME
    \ file file:new<CR>

"バッファ一覧
nnoremap <silent> [denite]b :<C-u>Denite
      \ -buffer-name=stay
      \ buffer<CR>

nnoremap <silent> \ :<C-u>Denite
    \ -winheight=5
    \ -start-filter
    \ -buffer-name=command
    \ command command_history<CR>

nnoremap <silent> [denite]/ :<C-u>Denite
    \ -buffer-name=search
    \ anzu<CR>

"neoyank
nnoremap <silent> [denite]y :<C-u>Denite
    \ -buffer-name=search
    \ neoyank register<CR>

"コマンド履歴
nnoremap <silent> [denite]c :<C-u>Denite
    \ -buffer-name=command
    \ -winheight=5
    \ -start-filter
    \ command_history<CR>

"バッファディレクトリからgrep
nnoremap <silent> [denite]g :<C-u>Denite
    \ -start-filter
    \ -path=`<SID>denite_gitdir()`
    \ `finddir('.git', '.;') != '' ? 'grep/git:::!' : 'grep'`<CR>

"メニュー
nnoremap <silent> [denite]u :<C-u>Denite
    \ -buffer_name=normal
      \ -winheight=5
    \ menu<CR>

"ヘルプ
nnoremap <silent> [denite]h :<C-u>Denite
    \ -buffer-name=search
    \ -start-filter
    \ help<CR>

"最近使用したファイル-neomru
nnoremap <silent> [denite]n :<C-u>Denite
    \ -buffer-name=normal
    \ file/old<CR>

"mark一覧
nnoremap <silent> [denite]m :<C-u>Denite
    \ -buffer-name=normal
    \ mark<CR>

":change
nnoremap <silent> [denite]k :<C-u>Denite change<CR>
":jump
nnoremap <silent> [denite]j :<C-u>Denite jump <CR>

"resumeして開く
nnoremap <silent> [denite]r :<C-u>Denite
    \ -buffer-name=search
    \ -refresh
    \ -resume<CR>

nnoremap <silent> [denite]R :<C-u>Denite
    \ -buffer-name=default
    \ -refresh
    \ -resume<CR>

"open ale message
nnoremap <silent> [denite]a :<C-u>Denite
    \ -buffer-name=stay
    \ -resume
    \ ale<CR>

"コマンド結果をdeniteに出力
nnoremap [denite]p :<C-u>Denite
    \ -buffer-name=search
    \ output:

" markdown TOC
nnoremap <silent> [denite]o :<C-u>Denite
    \ -buffer-name=stay
    \ markdown<CR>

nnoremap <silent> [denite]d :<C-u>Denite
    \ dirmark<CR>

"bookmark by "add"action
nnoremap <silent> [denite]D :<C-u>DeniteBufferDir
    \ dirmark/add<CR>
" autocmd vimrc FileType denite hi link CursorLine ColorColumn

" move next candidate
nnoremap <silent> [denite]. :<C-u>Denite
    \ -buffer-name=stay
    \ -resume
    \ -cursor-pos=+1
    \ -immediately
    \ <CR>

nnoremap <silent> [denite], :<C-u>Denite
    \ -resume
    \ -buffer-name=stay
    \ -cursor-pos=-1
    \ -immediately
    \ <CR>

''' #}}}
hook_source = ''' " {{{
call denite#custom#option('_', {
    \ 'winheight': 15,
    \ 'short_source_names': v:true,
    \ 'highlight_mode_normal': 'Visual',
    \ 'highlight_mode_insert': 'Visual',
    \ 'prompt': '#',
    \ 'highlight_matched_char' : 'Title',
    \ 'max_dynamic_update_candidates' : '50000',
    \ 'vertical_preview': v:false,
    \ 'statusline': v:true,
    \ 'direction': 'botright',
    \ 'quick_move_table': {
        \   'a' : 0, 's' : 1, 'd' : 2, 'f' : 3, 'g' : 4,
        \   'h' : 5, 'l' : 6, ';' : 7,
        \   'q' : 8, 'w' : 9, 'e' : 10, 'r' : 11, 't' : 12,
        \ }
    \ })
if has('nvim')
    call denite#custom#option('_',{
        \ 'filter_split_direction' : 'floating'
        \ })
endif
call denite#custom#option('normal', {
    \ 'winheight': 9
    \})
call denite#custom#option('search', {
    \ 'winheight': 9
    \ })
" call denite#custom#option('command', {
"     \ 'winheight': 5,
"     \ 'split': 'floating',
"     \ 'wincol': &columns/2,
"     \ 'winrow' : &lines/2
"     \ })
call denite#custom#option('stay',{
    \ 'split': 'floating',
    \ 'wincol': &columns/2-2,
    \ 'winwidth': &columns-5,
    \ 'winheight': 10,
    \ 'winrow' : &lines - 12
    \ })

""need rg for grep/file-rec
call denite#custom#var('file/rec', 'command',
    \ ['rg', '--files', '--no-messages','--hidden',
    \ '--glob', '!.git/*','-g','!*/.git/*','--glob','!*.tmp','-g','!AppData/*'])

call denite#custom#source('grep', 'args', ['', '', '!'])
call denite#custom#var('grep', 'command', ['rg', '--threads', '1'])
call denite#custom#var('grep', 'recursive_opts', [])
call denite#custom#var('grep', 'final_opts', [])
call denite#custom#var('grep', 'separator', ['--'])
call denite#custom#var('grep', 'default_opts',
      \ ['--vimgrep', '--no-heading'])

" Add custom menus
let s:menus = {
    \ }
let s:vimtex_commands = ['VimtexClean', 'VimtexTocOpen', 'VimtexTocToggle',
    \ 'VimtexCompileSS', 'VimtexRefreshFolds', 'VimtexReloadState', 'VimtexStop',
    \ 'VimtexStatus', 'VimtexCompile', 'VimtexStopAll', 'VimtexErrors', 'VimtexLog',
    \ 'VimtexCompileOutput', 'VimtexClean!', 'VimtexView', 'VimtexCountWords!',
    \ 'VimtexReload', 'VimtexDocPackage', 'VimtexCountLetters', 'VimtexCountWords',
    \ 'VimtexToggleMain', 'VimtexInfo', 'VimtexInfo!', 'VimtexCompileSelected',
    \ 'VimtexStatus!', 'VimtexRSearch', 'VimtexImapsList', 'VimtexCountLetters!']
let s:menus.tex = {'description': 'vimtex commands' }
let s:menus.tex.command_candidates = []
for v in range(len(s:vimtex_commands))
    let s:menus.tex.command_candidates += [[s:vimtex_commands[v], s:vimtex_commands[v]]]
endfor

let s:dein_commands = ['DeinInstall', 'DeinRecache', 'DeinUpdate']
let s:menus.dein = {'description': 'dein.vim commands' }
let s:menus.dein.command_candidates = []
for v in range(len(s:dein_commands))
    let s:menus.dein.command_candidates += [[s:dein_commands[v], s:dein_commands[v]]]
endfor
let s:menus.string = {'description': 'string utilities.'}
let s:menus.string.command_candidates = [
      \ ['format: reverse lines', 'g/^/m0'],
      \ ['format: remove ^M', '%s///g'],
      \ ['format: querystring', 'silent! %s/&amp;/\&/g | silent! %s/&/\r&/g | silent! %s/=/\r=/g'],
      \ ['format: to smb', 'silent! %s/\\/\//g | silent! %s/^\(smb:\/\/\|\/\/\)\?/smb:\/\//g']
      \ ]

call denite#custom#var('menu', 'menus', s:menus)

" call denite#custom#kind('file', 'default_action', 'drop')
" call denite#custom#source('file', 'matchers', ['matcher/fruzzy'])
" call denite#custom#source('file/rec', 'matchers', ['matcher/fruzzy'])
" Define alias
call denite#custom#alias('source', 'file/rec/git', 'file/rec')
call denite#custom#alias('source', 'grep/git', 'grep')
call denite#custom#var('grep/git', 'command', ['git', 'grep'])
" call denite#custom#source('_', 'sorters', ['sorter/reverse'])
call denite#custom#var('file/rec/git', 'command',
    \ ['git', 'ls-files', '-co', '--exclude-standard'])

"Change ignore_globs

call denite#custom#filter('matcher/ignore_globs', 'ignore_globs',
    \ [ '.git/', '.ropeproject/', '__pycache__/',
    \ 'venv/', 'images/','img/', 'fonts/',
    \ '*~', '*.o', '*.exe', '*.bak',
    \ '.DS_Store', '*.pyc', '*.sw[po]', '*.class',
    \ '.hg/', '.git/*', '.bzr/', '.svn/',
    \ 'tags', 'tags-*'])

" 現在いるDeniteDirでgrep
function! s:candidate_grep(context) abort
    let path = a:context['targets'][0]['action__path']
    let dir = denite#util#substitute_path_separator(path)
    if isdirectory(dir)
        let sdir = fnamemodify(dir, ':p:h')
    else
        let sdir = fnamemodify(dir, ':p')
    endif
    let sources_queue = a:context['sources_queue'] + [[
          \ {'name': 'grep', 'args': [sdir, '', '!']},
          \ ]]
    return {'is_interactive': v:false, 'sources_queue': sources_queue}
endfunction

function! s:denite_rec(context)
    let path = a:context['targets'][0]['action__path']
    let dir = denite#util#substitute_path_separator(path)
    if isdirectory(dir)
        let sdir = fnamemodify(dir, ':p:h')
    else
        let sdir = fnamemodify(dir, ':p')
    endif
    let fdir = '\"' . sdir. '\"'
    execute('Denite file/rec:' . sdir)
endfunction

function! s:denite_directory_rec(context)
    let path = a:context['targets'][0]['action__path']
    let dir = denite#util#substitute_path_separator(path)
    " if isdirectory(dir)
    "     let sdir = fnamemodify(dir, ':p:h:h')
    " else
        let sdir = fnamemodify(dir, ':p:h')
    " endif
    let fdir = '\"' . sdir . '\"'
    execute('Denite directory_rec:' . sdir)
endfunction

call denite#custom#action(
    \ 'buffer,directory,file,openable,dirmark', 'directory/rec',
    \ function('s:denite_directory_rec')
    \ )

call denite#custom#action(
    \ 'buffer,directory,file,openable,dirmark', 'grep',
    \ function('s:candidate_grep')
    \ )
call denite#custom#action(
    \ 'buffer,directory,file,openable,dirmark,dirmark', 'file/rec',
    \ function('s:denite_rec')
    \ )

"Defxで開く
function! s:defx_open(context)
    let path = a:context['targets'][0]['action__path']
    let file = fnamemodify(path, ':p')
    let file_search = filereadable(expand(file)) ? ' -search=' . file : ''
    let dir = denite#util#path2directory(path)
    if &filetype ==# 'defx'
      call defx#call_action('cd', [dir])
      call defx#call_action('search', [path])
    else
      execute('Defx ' . dir . file_search)
    endif
endfunction

"action:defxを定義
call denite#custom#action(
    \ 'directory,file,openable,dirmark',
    \ 'defx',
    \  function('s:defx_open'))

"sorter定義
function! ToggleSorter(sorter) abort
   let sorters = split(b:denite_context.sorters, ',')
   let idx = index(sorters, a:sorter)
   if idx < 0
       call add(sorters, a:sorter)
   else
       call remove(sorters, idx)
   endif
   let b:denite_new_context = {}
   let b:denite_new_context.sorters = join(sorters, ',')
   return '<denite:nop>'
endfunction
''' # }}}

[plugins.ftplugin]
denite = ''' "{{{
if has('nvim')
    setlocal winblend=0
endif
setlocal signcolumn=yes
" nnoremap <silent><buffer><expr> j
" \ line('.') == line('$') ? 'gg' : 'j'
" nnoremap <silent><buffer><expr> k
" \ line('.') == 1 ? 'G' : 'k'
nnoremap <silent><buffer><expr> <TAB>
    \ denite#do_map('choose_action')
nnoremap <silent><buffer><expr> <CR>
    \ denite#do_map('do_action')
nnoremap <silent><buffer><expr> s
    \ denite#do_map('do_action', 'splitswitch')
nnoremap <silent><buffer><expr> v
    \ denite#do_map('do_action', 'vsplitswitch')
nnoremap <silent><buffer><expr> h
    \ denite#do_map('move_up_path')
nnoremap <silent><buffer><expr> d
    \ denite#do_map('do_action', 'delete')
nnoremap <silent><buffer><expr> l
    \ denite#do_map('do_action')
nnoremap <silent><buffer><expr> p
    \ denite#do_map('do_action', 'preview')
nnoremap <silent><buffer><expr> q
    \ denite#do_map('quit')
nnoremap <silent><buffer><expr> i
    \ denite#do_map('open_filter_buffer')
nnoremap <silent><buffer><expr> t
    \ denite#do_map('toggle_select').'j'
nnoremap <silent><buffer><expr> r
    \ denite#do_map('toggle_matchers:regexp')
nnoremap <silent><buffer><expr> <C-r>
    \ denite#do_map('do_action','file/rec')
nnoremap <silent><buffer><expr> <C-e>
    \ denite#do_map('do_action','defx')
nnoremap <silent><buffer><expr> <C-d>
    \ denite#do_map('do_action','directory_rec')
nnoremap <silent><buffer><expr> <C-g>
    \ denite#do_map('do_action','grep')
nnoremap <silent><buffer><expr> <C-s>
    \ denite#do_map('change_sorters', 'sorter/rank,sorter/word')
''' # }}}
denite-filter = ''' " {{{
setlocal winblend=100
imap <silent><buffer><expr> <CR>
    \ denite#get_status('buffer_name') is# 'command'
    \ ? "\<ESC>\<CR>"
    \ : "<Plug>(denite_filter_update)"
nnoremap <silent><buffer> j  <C-w>p:call cursor(line('.')+1,0)<CR><C-w>p
nnoremap <silent><buffer> k  <C-w>p:call cursor(line('.')-1,0)<CR><C-w>p
inoremap <silent><buffer> <C-j>  <C-w>p:call cursor(line('.')+1,0)<CR><C-w>p
inoremap <silent><buffer> <C-k>  <C-w>p:call cursor(line('.')-1,0)<CR><C-w>p
inoremap <silent><buffer><expr> <C-l> denite#do_map('do_action')
inoremap <silent><buffer><expr> <Tab> denite#do_map('choose_action')
imap <silent><buffer> <C-c> <Plug>(denite_filter_update)
imap <silent><buffer> <C-[> <Plug>(denite_filter_update)
imap <silent><buffer> <ESC> <Plug>(denite_filter_update)
imap <silent><buffer> <C-q> <Plug>(denite_filter_quit)q
nmap <silent><buffer> q <Plug>(denite_filter_quit)q
''' # }}}

[[plugins]]
repo =  'Shougo/neoyank.vim'
on_event = 'TextYankPost'
on_source = ['denite.nvim']

[[plugins]]
repo =  'Shougo/unite.vim'
on_cmd = ['Unite']

[[plugins]]
repo = 'glidenote/memolist.vim'
on_cmd = ['MemoNew', 'MemoGrep' , 'MemoList']
hook_add = ''' " {{{
nnoremap <Leader>mn  :MemoNew<CR>
nnoremap <silent><Leader>ml  :<C-u>Denite 
    \ -buffer-name=normal
    \ file/rec:~/GoogleDrive/memo<CR>
nnoremap <silent><Leader>mg  :<C-u>Denite 
    \ -buffer-name=normal
    \ grep:~/GoogleDrive/memo::<CR>
" use denite (default 0)
let g:memolist_denite = 1
let g:memolist_path = "~/GoogleDrive/memo"
let g:memolist_template_dir_path = "~/GoogleDrive/memo/template"
let g:memolist_memo_suffix = "markdown"
let g:memolist_memo_date = "%Y-%m-%d[%H:%M]"
" categories prompt (default 0)
let g:memolist_prompt_categories = 1
''' # }}}

[[plugins]]
repo =  'Shougo/defx.nvim'
on_cmd = 'Defx'
hook_add = ''' " {{{
nmap <C-e> <Plug>(defx)
nmap <Leader>e <Plug>(defxbufferdir)
nmap <Leader>E <Plug>(defxprojectdir)

nnoremap <silent> <Plug>(defx) :<C-u>Defx -resume<CR>
nnoremap <silent> <Plug>(defxbufferdir) :<C-u>Defx `expand('%:p:h')` -search=`expand('%:p')`<CR>
nnoremap <silent> <Plug>(defxprojectdir) :<C-u>Defx -search=$HOME<CR>
''' # }}}
hook_source = ''' " {{{

call defx#custom#option('_', {
    \ 'winwidth': 35,
    \ 'split': 'vertical',
    \ 'direction': 'topleft',
    \ 'columns':'mark:indent:icons:filename',
    \ 'sort': 'TIME',
    \ 'drives': [ expand('~/GoogleDrive'), expand('~')],
    \ 'ignored_files':  '.*,*.aux, ntuser*, desktop.ini , __pycache__'
    \ })
"call defx#custom#column('filename', {
"      \ 'directory_icon': '',
"      \ 'opened_icon': '',
"      \ 'root_icon': '',
"      \ 'min_width': 45,
"      \ 'max_width': 45,
"      \ })

function! s:get_defx_bufferdir(candidate) abort
    if line('.') == 1
        let path_mod  = 'h'
    else
        let path_mod = isdirectory(a:candidate) ? '' : 'h'
    endif
    return fnamemodify(a:candidate,'\":p:' . path_mod . '\"')
endfunction

function! Defx_to_denite_rec(context) abort
        let narrow_dir = '\"' . s:get_defx_bufferdir(a:context.targets[0]) . '\"'
        silent! execute('Denite
        \ -default-action=defx
        \ file/rec:' .  narrow_dir)
endfunction
''' # }}}
[plugins.ftplugin]
defx = ''' " {{{
nmap <silent><buffer> [denite]d <Plug>(defx):<C-u>Denite
    \ -buffer-name=normal
    \ defx/dirmark<CR>
nmap <silent><buffer> [denite]h <Plug>(defx):<C-u>Denite
    \ -buffer-name=normal
    \ defx/history<CR>
setlocal signcolumn=no
" Define mappings
nnoremap <silent><buffer><expr> <CR>
\ defx#do_action('drop')
nnoremap <silent><buffer><expr> c
\ defx#async_action('copy')
nnoremap <silent><buffer><expr> m
\ defx#async_action('move')
nnoremap <silent><buffer><expr> p
\ defx#async_action('paste')
nnoremap <silent><buffer><expr> l 
\ defx#is_directory() ?
\ defx#do_action('open') :
\ defx#do_action('drop')
nnoremap <silent><buffer><expr> E
\ defx#do_action('open', 'vsplit')
nnoremap <silent><buffer><expr> t
\ defx#do_action('multi', ['toggle_sort','filename','redraw'])
nnoremap <silent><buffer><expr> T
\ defx#do_action('multi', [['toggle_sort','TIME'],'redraw'])
nnoremap <silent><buffer><expr> P
\ defx#do_action('open', 'pedit')
nnoremap <silent><buffer><expr> K
\ defx#do_action('new_directory')
nnoremap <silent><buffer><expr> N
\ defx#do_action('new_file')
"need 'pip install Send2Trash'
nnoremap <silent><buffer><expr> d
\ defx#async_action('remove_trash')
nnoremap <silent><buffer><expr> r
\ defx#do_action('rename')
nnoremap <silent><buffer><expr> x
\ defx#async_action('execute_system')
nnoremap <silent><buffer><expr> f
\ defx#do_action('open_or_close_tree')
nnoremap <silent><buffer><expr> yy
\ defx#do_action('yank_path')
nnoremap <silent><buffer><expr> .
\ defx#do_action('toggle_ignored_files')
nnoremap <silent><buffer><expr> h
\ defx#do_action('cd', ['..'])
nnoremap <silent><buffer><expr> ~
\ defx#do_action('cd')
nnoremap <silent><buffer><expr> q
\ defx#do_action('quit')
nnoremap <silent><buffer><expr> i
\ defx#do_action('toggle_select') . 'j'
nnoremap <silent><buffer><expr> I
\ defx#do_action('clear_select_all')
nnoremap <silent><buffer><expr> *
\ defx#do_action('toggle_select_all')
nnoremap <silent><buffer><expr> j
\ line('.') == line('$') ? 'gg' : 'j'
nnoremap <silent><buffer><expr> k
\ line('.') == 1 ? 'G' : 'k'
nnoremap <silent><buffer><expr> <C-g>
\ defx#do_action('print')
nnoremap <silent><buffer><expr> cd
\ defx#do_action('change_vim_cwd')
nnoremap <silent><buffer><expr> <C-r>
\ defx#do_action('call','Defx_to_denite_rec')
''' # }}}
[[plugins]]
repo = 'kristijanhusak/defx-icons'
on_source = 'defx.nvim'
hook_source = ''' " {{{
"NerdFont List{{{
"This list is useful for testing and choosing interesting symbols.
"Also it's more consistent with current fonts than codepoints shown in README.
"So, it may worth to add this to the wiki - I've opened issue just to ask is this appropriate. Probably it's better to put it on page with Nerd font loaded.
"
"IEC Power Symbols (23FB-23FE,2B58)
"⏻⏼⏽⏾⭘
"Font Awesome Extension (moved E000-E0A9 → E200-E2A9)
"
"
"
"
"
"Powerline Extra Symbols (E0A0-E0A3 E0B0-E0BF E0C0-E0C8 E0CC-E0CF E0D0-E0D2 E0D4)
"
"Devicons (moved E600-E6C5 → E700-E7C5)
"
"
"
"
"
"Font Awesome (F000-F2E0 with holes)
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"Octicons (2665,26A1, moved F000-F105 with holes → F400-F4A8, moved F27C → F67C)
"♥⚡
"
"
"
"
"
"Pomicons (E000-E00A)
"
"Font Linux (moved F100-F115 with holes → F300-F313)
"
"Seti-UI + Custom (E5FA-E62B)
"
"
"}}}
let g:defx_icons_enable_syntax_highlight = 1
let g:defx_icons_column_length = 2
let g:defx_icons_directory_icon = ''
let g:defx_icons_mark_icon = '*'
let g:defx_icons_parent_icon = ''
let g:defx_icons_default_icon = ''
let g:defx_icons_directory_symlink_icon = ''
" Options below are applicable only when using "tree" feature
let g:defx_icons_root_opened_tree_icon = ''
let g:defx_icons_nested_opened_tree_icon = ''
let g:defx_icons_nested_closed_tree_icon = ''
let s:colors = {
      \ 'brown': '905532',
      \ 'aqua': '3AFFDB',
      \ 'blue': '689FB6',
      \ 'darkBlue': '44788E',
      \ 'purple': '834F79',
      \ 'lightPurple': '834F79',
      \ 'red': 'AE403F',
      \ 'beige': 'F5C06F',
      \ 'yellow': 'F09F17',
      \ 'orange': 'D4843E',
      \ 'darkOrange': 'F16529',
      \ 'pink': 'CB6F6F',
      \ 'salmon': 'EE6E73',
      \ 'green': '8FAA54',
      \ 'lightGreen': '31B53E',
      \ 'white': 'C6C8D1'
      \ }
let g:defx_icons_extensions = {
    \'txt' : { 'icon':'', 'color': s:colors.white},
    \'pdf' : { 'icon':'', 'color': s:colors.red},
    \'docx' : { 'icon':'', 'color': s:colors.blue},
    \'doc' : { 'icon':'', 'color': s:colors.blue},
    \'xlsx' : { 'icon':'', 'color': s:colors.green},
    \'pptx' : { 'icon':'', 'color': s:colors.orange},
    \'ppt' : { 'icon':'', 'color': s:colors.orange}
    \}
''' #}}}

[[plugins]]
repo = 'Shougo/deol.nvim'
on_cmd = ['Deol']
hook_add = '''
nnoremap <Leader>d :Deol -edit -split='vertical'<CR>
'''

[[plugins]]
repo =  'Shougo/deoplete.nvim'
on_if = ''' has('nvim') '''
on_event = 'InsertEnter'
hook_source = ''' " {{{
let g:deoplete#enable_at_startup = 1
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ deoplete#manual_complete()
function! s:check_back_space() abort "{{{
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction "}}}
inoremap <silent><expr> <C-n>
    \ pumvisible() ? "\<C-n>" :
    \ deoplete#manual_complete()
''' # }}}
hook_source = ''' " {{{
inoremap <silent><expr><C-h>
    \ deoplete#smart_close_popup()."\<C-h>"
inoremap <silent><expr><BS>
    \ deoplete#smart_close_popup()."\<C-h>"
inoremap <silent><expr><C-l> 
    \ deoplete#complete_common_string()
inoremap <expr><silent> <C-g>
    \ pumvisible() ? deoplete#undo_completion() : "\<C-g>"
"
"" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function() abort
  return pumvisible() ? deoplete#close_popup() : "\<CR>"
endfunction

call deoplete#custom#source('_', 'matchers',
      \ ['matcher_fuzzy', 'matcher_length'])
"eskkにmatcherを指定してはいけない
call deoplete#custom#source('eskk', 'matchers', [])
call deoplete#custom#source('eskk', 'mark' , '▼')
call deoplete#custom#source('vim', 'rank' , 200)
call deoplete#custom#source('file', 'rank', 1000)
call deoplete#custom#source('neosnippet', 'rank', 250)
call deoplete#custom#source('buffer', 'rank', 200)
call deoplete#custom#source('look', 'rank', 50)
call deoplete#custom#source('omni', 'mark' , '*')
call deoplete#custom#source('omni', 'functions' , {
    \ 'python': '',
    \ })

call deoplete#custom#var('around', {
    \   'range_above': 20,
    \   'range_below': 20,
    \   'mark_above': '[↑]',
    \   'mark_below': '[↓]',
    \   'mark_changes': '[*]',
    \})
call deoplete#custom#option('sources', {
    \ 'denite-filter': ['denite'],
    \ 'python': ['lsp'],
    \ 'go': ['lsp','vsnip','buffer'],
    \ })
call deoplete#custom#option({
    \ 'refresh_always': v:false,
    \ 'skip_multibyte': v:true,
    \ 'min_pattern_length': 2,
    \ 'prev_completion_mode': 'filter',
    \ 'ignore_sources': {
    \    }
    \ })

call deoplete#custom#source('_', 'converters', [
    \ 'converter_remove_paren',
    \ 'converter_remove_overlap',
    \ 'converter_truncate_abbr',
    \ 'converter_truncate_menu',
    \ 'converter_truncate_kind',
    \ 'converter_auto_delimiter'
    \ ])

call deoplete#enable()
''' # }}}

# [[plugins]]
# repo = 'Shougo/neocomplete.vim'
# on_if = ''' !has('nvim') '''
# on_event = 'InsertEnter'
# hook_source = ''' " {{{
# let g:neocomplete#enable_smart_case = 1
# "let g:neocomplete#enable_auto_select = 1

# "vimprocを有効化すると初回の補完がちょっと遅くなる
# let g:neocomplete#use_vimproc = 1
# let g:neocomplete#min_keyword_length = 2
# " Define keyword.
# " Plugin key-madeinppings.
# inoremap <expr><C-g>     neocomplete#undo_completion()
# inoremap <expr><C-l>     neocomplete#complete_common_string()
# " Recommended key-mappings.
# " <CR>: close popup and save indent.
# inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
# function! s:my_cr_function()
#   return pumvisible() ? "\<C-y>" : "\<CR>"
# endfunction
# inoremap <silent><expr> <C-n>
#     \ pumvisible() ? "\<C-n>" :
#     \ neocomplete#start_manual_complete()
# " <TAB>: completion.
# inoremap <silent><expr> <TAB>
#     \ pumvisible() ? "\<C-n>" :
#     \ neosnippet#expandable_or_jumpable() ?
#     \    "\<Plug>(neosnippet_expand_or_jump)" :
#     \ <SID>check_back_space() ? "\<TAB>" :
#     \ neocomplete#start_manual_complete()
# function! s:check_back_space() abort "{{{
#   let col = col('.') - 1
#   return !col || getline('.')[col - 1]  =~ '\s'
# endfunction"}}}
# " <C-h>, <BS>: close popup and delete backword char.
# inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
# inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
# let g:neocomplete#sources#buffer#cache_limit_size = 500000
# let g:neocomplete#auto_complete_delay = 1
# let g:neocomplete#skip_auto_completion_time = '0.2'
# let g:neocomplete#enable_multibyte_completion = 1

# if !exists('g:neocomplete#keyword_patterns')
#   let g:neocomplete#keyword_patterns = {}
# endif

# "let g:neocomplete#keyword_patterns['default'] = '\k\+'
# let g:neocomplete#max_list=300
# "call neocomplete#custom#source('_', 'matchers', ['matcher_head','matcher_length'])
# " Change default converter.
# "call neocomplete#custom#source('_', 'converters',
# "\ ['converter_remove_overlap', 'converter_remove_last_paren',
# "    \  'converter_abbr'])
# call neocomplete#custom#source('eskk', 'rank', 500) 
# call neocomplete#custom#source('vim', 'rank' , 250)
# call neocomplete#custom#source('buffer', 'mark', 'b')
# call neocomplete#custom#source('eskk', 'mark' , '▽')
# call neocomplete#custom#source('eskk', 'max_menu_width', 80)
# let g:neocomplete#ignore_source_files = [
#     \'member', 'tag.vim', 'dictionary.vim', 'include.vim', 'file_include.vim'
#     \]
# call neocomplete#initialize()
# ''' # }}}

[[plugins]]
repo =  'Shougo/neco-vim'
on_source = ['deoplete','neocomplete']
on_ft = 'vim'

[[plugins]]
repo =  'Shougo/neosnippet'
on_event = 'InsertEnter'
on_ft = 'snippet'
hook_source = ''' " {{{
" let g:neosnippet#disable_runtime_snippets = {
" \   '_' : 1,
" \ }
if has('conceal')
    set conceallevel=2 concealcursor=niv
endif
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
''' # }}}

[[plugins]]
repo =  'tyru/eskk.vim'
on_map = {icrtn = '<Plug>(eskk:'}
hook_add = ''' " {{{

"let g:eskk#marker_henkan = '' "''
let g:eskk#marker_okuri = '*'
" let g:eskk#marker_henkan_select = '' " ''
let g:eskk#rom_input_style = 'skk'
let g:eskk#egg_like_newline = 1
let g:eskk#egg_like_newline_completion = 1
let g:eskk#tab_select_completion = 1
let g:eskk#start_completion_length = 2
let g:eskk#revert_henkan_style = 'okuri'
" backspaceで確定
let g:eskk#delete_implies_kakutei = 1
let g:eskk#dictionary = {
    \    'path': "~/GoogleDrive/rc/.skk-jisyo",
    \    'sorted': 0,
    \    'encoding': 'utf-8'
    \}
let g:eskk#set_undo_point = {
    \ 'sticky' : 0,
    \ 'kakutei' : 0
    \ }

let g:eskk#large_dictionary = {'path': '~/.skk/SKK-JISYO.L', 'sorted': 1, 'encoding': 'euc-jp', }
let g:eskk#dictionary_save_count = 5
let g:eskk#cursor_color = {
    \   'ascii': '#b4be82',
    \   'hira': '#e28878',
    \   'kata': '#84a0c6',
    \   'abbrev': '#4169e1',
    \   'zenei': '#ffd700',
    \}

imap <C-j> <Plug>(eskk:toggle)
cmap <C-j> <Plug>(eskk:toggle)

''' # }}}
hook_source = ''' " {{{
autocmd vimrc User eskk-initialize-pre call s:eskk_initial_pre()

function! s:eskk_initial_pre() abort
    let t = eskk#table#new('rom_to_hira*', 'rom_to_hira')
    call t.add_map('z ', '　')
    call t.add_map('~', '〜')
    call t.add_map('zc', '©')
    call t.add_map('zr', '®')
    call t.add_map('z9', '（')
    call t.add_map('z0', '）')
    call t.add_map('z-', '-')
      " "1." のように数字の後のドットはそのまま入力
    for n in range(10)
      call t.add_map(n . '.', n . '.')
    endfor
    call eskk#register_mode_table('hira', t)
    " CursorLineNrを保存
    let s:eskk_default_linenr_hi =s:gethighlight('CursorLineNr')
endfunction
" eskk_keep_stateがうまく動かないので自前で設定
nnoremap <silent><C-j> :call <SID>eskk_norm_toggle()<CR>

let s:eskk_status = 0
let g:eskk_toggle_status = 0

"TODO :qitta
augroup myeskk
autocmd!
    autocmd InsertLeave * call <SID>eskk_save_status()
    autocmd InsertEnter * call <SID>eskk_insert_status()
augroup END

" ノーマルモードでもeskkの状態を操作する
function! s:eskk_norm_toggle() abort
    if s:eskk_status || g:eskk_toggle_status
        " eskkがオンの時に呼ぶとただオフにする
        let s:eskk_status = 0
        let g:eskk_toggle_status = 0
        call s:eskk_restore_highlight_linenr()
    else
        " eskkがオフの時に呼ぶと常にeskk onでインサートモードに入る状態になる
        let g:eskk_toggle_status = 1
        call s:eskk_highlight_linenr()
    endif
endfunction

function! s:eskk_save_status() abort
    if g:eskk_toggle_status
        call s:eskk_highlight_linenr()
        return
    endif
    let s:eskk_status = eskk#is_enabled() ? 1 : 0
endfunction

function! s:eskk_insert_status() abort
    if &filetype ==# 'denite-filter' | return | endif
    if g:eskk_toggle_status || s:eskk_status
        call eskk#enable()
    endif
endfunction

" lightline用の関数
function! LLmyeskk() abort
    if !exists('*eskk#enable') | return 'aA' | endif
    if eskk#is_enabled()
        return printf(get(a:000, 0, '%s'),
            \ get(g:eskk#statusline_mode_strings,
            \ eskk#get_current_instance().mode, '??'))
    elseif mode() !=# 'i'
        return g:eskk_toggle_status || s:eskk_status ? 'あ' : 'aA'
    else
        return 'aA'
    endif

endfunction

"IME/skkの状態に応じてsigncolumnの色を変える（WIP）

autocmd vimrc User eskk-enable-post call s:eskk_enable_post()
" InsertLeaveの前に発生するイベントであることに注意する
autocmd vimrc User eskk-disable-post call s:eskk_restore_highlight_linenr()

function! s:eskk_enable_post()
    " lでeskkを終了
    EskkMap -type=disable l
    " ハイライトを有効化
    call s:eskk_highlight_linenr()
endfunction

function! s:eskk_restore_highlight_linenr()
    let l:hi = 'highlight! CursorLineNr ' . s:eskk_default_linenr_hi
    if mode() is# 'i'
        silent execute(l:hi)
    else
        " statusが1のときは戻さない
        if g:eskk_toggle_status || s:eskk_status
            return
        else
            silent execute(l:hi)
        endif
    endif
endfunction

"もともとのhighlightを保存
function! s:gethighlight(hi) abort
    redir => hl
    silent execute 'highlight ' . a:hi
    redir END

    let hl = substitute(hl, '\w*\ze\s\{3}', '', 'g')
    let hl = substitute(hl, 'xxx', '', '')
    let hl = substitute(hl, '\n', '', '')
    let hl = substitute(hl, 'links to .*', '', 'g')
    " bgが無い場合適当な色を埋め込む
    let hl = match(hl, 'guibg') == -1 ? 'guibg=#002b36 ' . hl : hl
    return hl
endfunction

function! s:eskk_highlight_linenr() abort
    " eskkがonの時のhighlightを指定
    let s:eskk_hl = 'highlight CursorLineNr guibg=#b58900 cterm=bold ctermfg=0 ctermbg=11 gui=bold guifg=#073642 '
    silent execute(s:eskk_hl)
endfunction

" ColorSchemeが変わった時に読み込み直す
autocmd ColorScheme * let s:eskk_default_linenr_hi =s:gethighlight('CursorLineNr')
''' # }}}

[[plugins]]
repo =  'cohama/lexima.vim'
on_if = 'has("nvim")'
on_event = 'InsertEnter'
hook_add = '''
"let g:lexima_no_default_rules = 1
"call lexima#set_default_rules()
let g:lexima_enable_basic_rules = 0
let g:lexima_enable_space_rules = 0
let g:lexima_nvim_accept_pum_with_enter = 0
let g:lexima_ctrlh_as_backspace = 1
let g:lexima_map_escape = ''
'''

hook_post_source = ''' " {{{
let s:lexima_default_rules = [
\ {'char': '(', 'input_after': ')'},
\ {'char': '(', 'at': '\\\%#'},
\ {'char': ')', 'at': '\%#)', 'leave': 1},
\ {'char': '<BS>', 'at': '(\%#)', 'delete': 1},
\ {'char': '{', 'input_after': '}'},
\ {'char': '}', 'at': '\%#}', 'leave': 1},
\ {'char': '<BS>', 'at': '{\%#}', 'delete': 1},
\ {'char': '[', 'input_after': ']'},
\ {'char': '[', 'at': '\\\%#'},
\ {'char': ']', 'at': '\%#]', 'leave': 1},
\ ]

for rule in s:lexima_default_rules
  call lexima#add_rule(rule)
endfor

let s:lexima_my_rules = [
\ {'char': 'z[', 'input': '「', 'input_after': '」'},
\ {'char': 'z{', 'input': '『', 'input_after': '』'},
\ {'char': 'z\', 'input': '【', 'input_after': '】'},
\ {'char': 'z(', 'input': '（', 'input_after': '）'},
\ {'char': '<BS>', 'at': '「\%#」', 'delete' : 1},
\ {'char': '<BS>', 'at': '『\%#』', 'delete' : 1},
\ {'char': '<BS>', 'at': '【\%#】', 'delete' : 1},
\ {'char': '<BS>', 'at': '（\%#）', 'delete' : 1},
\ ]

for rule in s:lexima_my_rules
  call lexima#add_rule(rule)
endfor
''' # }}}

[[plugins]]
repo = 'kana/vim-operator-replace'
depends = 'vim-operator-user'
on_map = {nv = '<Plug>(operator-replace'}
hook_add = '''
nmap _ <Plug>(operator-replace)
vmap _ <Plug>(operator-replace)
'''

# [[plugins]]
# repo =  'lambdalisue/gina.vim'{{{
# on_cmd = ['Gina'] 
# hook_add = '''
# nnoremap <Leader>aa :<C-u>Gina status --short<CR>
# nnoremap <Leader>ac :<C-u>Gina commit<CR>
# nnoremap <Leader>ap :<C-u>Gina push<CR>
# '''
# hook_post_source = '''
# "{{{
# call gina#custom#command#alias('branch', 'br')
# call gina#custom#command#option('br', '-v', 'v')
# call gina#custom#command#option(
# \ '/\%(log\|reflog\)',
# \ '--opener', 'vsplit'
# \)

# call gina#custom#command#option(
# \ '/\%(status\|branch\|ls\|grep\|changes\|tag\)',
# \ '--opener' , '10split'
# \)
# call gina#custom#command#option(
# \ 'log', '--group', 'log-viewer'
# \)
# call gina#custom#command#option(
# \ 'status', '--group', 'status-viewer'
# \)
# call gina#custom#command#option(
# \ 'reflog', '--group', 'reflog-viewer'
# \)
# call gina#custom#command#option(
# \ 'commit', '-v|--verbose'
# \)
# call gina#custom#command#option(
# \ '/\%(status\|commit\)',
# \ '-u|--untracked-files'
# \)
# call gina#custom#command#option(
# \ '/\%(status\|changes\)',
# \ '--ignore-submodules'
# \)

# call gina#custom#action#alias(
# \ 'branch', 'track',
# \ 'checkout:track'
# \)
# call gina#custom#action#alias(
# \ 'branch', 'merge',
# \ 'commit:merge'
# \)
# call gina#custom#action#alias(
# \ 'branch', 'rebase',
# \ 'commit:rebase'
# \)

# call gina#custom#mapping#nmap(
# \ 'branch', 'g<CR>',
# \ '<Plug>(gina-commit-checkout-track)'
# \)
# call gina#custom#mapping#nmap(
# \ 'status', '<C-^>',
# \ ':<C-u>Gina commit<CR>',
# \ {'noremap': 1, 'silent': 1}
# \)
# call gina#custom#mapping#nmap(
# \ 'commit', '<C-^>',
# \ ':<C-u>Gina status<CR>',
# \ {'noremap': 1, 'silent': 1}
# \)

# "call gina#custom#execute(
# "\ '/\%(status\|branch\|ls\|grep\|changes\|tag\)',
# "\ 'setlocal winfixheight',
# "\)
# "}}}
# '''

# [[plugins]]
# repo =  'sjl/gundo.vim'
# on_cmd = 'GundoToggle'
# hook_add = '''
# nnoremap U :<C-u>GundoToggle<CR>
# '''
# hook_source = '''
# "{{{
# let g:gundo_help =1 
# let g:gundo_prefer_python3 = 1
# let g:gundo_auto_preview = 0
# let g:gundo_width = 50
# let g:gundo_right = 1
# let g:gundo_preview_height = 20
# let g:gundo_preview_bottom = 0
# let g:gundo_playback_delay = 500
# "}}}
# '''
# }}}

[[plugins]]
repo =  'nathanaelkane/vim-indent-guides'
on_cmd = 'IndentGuideToggle'
hook_add = '''
nnoremap <silent><Leader>ig :IndentGuidesToggle<CR>
'''
hook_source ='''
let g:indent_guides_exclude_filetypes = ['help', 'defx']
'''

[[plugins]]
#repo =  'dense-analysis/ale'
repo =  'orokasan/ale'
on_event = 'InsertLeave'
hook_source =''' " {{{
"https://efcl.info/2015/09/10/introduce-textlint/
"https://koirand.github.io/blog/2018/textlint/
"vint: pip install --pre vim-vint
"preset-ja-technical-writing
"npm install textlint-rule-preset-ja-technical-writing@beta
let g:ale_echo_delay = 400
let g:ale_textlint_change_directory = 1
let g:ale_disable_lsp = 1
let g:ale_use_global_executables=1
let g:ale_set_balloons =0
let g:ale_linters = {
    \ 'markdown': ['textlint'],
    \ 'pandoc' : ['textlint'],
    \ 'vim':['vint'],
    \ 'python': [''],
    \ 'go': [''],
    \ 'text':['textlint']
    \ }
let g:ale_echo_msg_format = '%code: %%s [%linter%]'
let g:ale_set_loclist = 0
let g:ale_set_quickfix = 1
let g:ale_textlint_options = '.textlintrc'
let g:ale_sign_column_always = 1
let g:ale_lint_delay = 5000
let g:ale_lint_on_enter = 0
let g:ale_lint_on_text_changed = 0
let g:ale_lint_on_filetype_changed = 0
let g:ale_open_list = 0
let g:ale_keep_list_window_open = 0
let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
if has('mac')
    let g:ale_sign_error = ''
    let g:ale_sign_warning = ''
    let g:ale_statusline_format = ['%d', '%d', '']
else
    let g:ale_sign_error = ''
    let g:ale_sign_warning = ''
    let g:ale_statusline_format = ['%d', '%d', '']
endif
''' # }}}

[[plugins]]
repo =  't9md/vim-choosewin'
#TODO:qitta
on_map = {n = '<Plug>(choosewin'}
hook_add = ''' " {{{
nmap - <Plug>(choosewin)
nmap - <C-\><C-n><Plug>(choosewin)
" let g:choosewin_overlay_font_size = 'small'
" let g:choosewin_overlay_clear_multibyte = 1
" let g:choosewin_overlay_enable = 1
" let g:choosewin_color_overlay = {
"    \ 'gui': ['#839496']
"    \ }
" let g:choosewin_color_overlay_current = {
"    \ 'gui': ['#859900']
"    \ }
let g:choosewin_color_label_current = {
      \ 'gui': ['#859900' , '#002b36', 'bold']
      \ }
let g:choosewin_color_label = {
      \ 'gui': [ '#073642', '#fdf6e3', 'bold']
      \ }
let g:choosewin_color_other = {
      \ 'gui': ['#002b36', '#657b83']
      \ }
let g:choosewin_tabline_replace = 0
let g:choosewin_statusline_replace = 1
let s:keymap = {
      \ '0':     'tab_first',
      \ '[':     'tab_prev',
      \ ']':     'tab_next',
      \ '$':     'tab_last',
      \ 'x':     'tab_close',
      \ ';':     'win_land',
      \ '-':     'previous',
      \ 's':     'swap',
      \ 'S':     'swap_stay',
      \ "\<CR>": 'win_land',
      \ }
let g:choosewin_keymap = s:keymap
let g:choosewin_label = 'HJKLADFG'
let g:choosewin_blink_on_land = 0
''' # }}}

[[plugins]]
repo = 'previm/previm'
depends = 'open-browser.vim'
on_ft = ['markdown','md']
hook_add = '''
let g:previm_open_cmd = 'open -a Safari'
nnoremap <silent><Leader>mp :PrevimOpen<CR>
'''

[[plugins]]
repo =  'rhysd/vim-operator-surround'
depends = 'vim-operator-user'
on_map = {nv= '<Plug>'}
hook_add = ''' " {{{
map <silent>'a <Plug>(operator-surround-append)
map <silent>'d <Plug>(operator-surround-delete)
map <silent>'r <Plug>(operator-surround-replace)
''' # }}}
hook_source = ''' " {{{
"2バイト括弧を追加
let g:operator#surround#blocks = {}
let g:operator#surround#blocks['-'] = [
\   { 'block' : ['（', '）'], 'motionwise' : ['char', 'line', 'block'], 'keys' : ['B'] },
\   { 'block' : ['「', '」'], 'motionwise' : ['char', 'line', 'block'], 'keys' : ['K'] },
\   { 'block' : ['『', '』'], 'motionwise' : ['char', 'line', 'block'], 'keys' : ['D'] },
\ ]
''' # }}}

[[plugins]]
repo = 'itchyny/vim-cursorword'
on_map = {nv='<Plug>'}
hook_add = ''' " {{{
let g:cursorword = 0
function! s:toggle_vim_cursorword() abort
  let g:cursorword = g:cursorword ? 0 : 1
  call cursorword#matchadd()
endfunction
nnoremap <silent> <Plug>(cursorword-toggle)
      \ :<C-u>call <SID>toggle_vim_cursorword()<CR>
nmap <C-g>c     <Plug>(cursorword-toggle)
nmap <C-g><C-c> <Plug>(cursorword-toggle)
''' # }}}

[[plugins]]
repo = 'osyo-manga/vim-precious'
on_ft = 'toml'
hook_source = ''' " {{{
" カーソル移動時の自動切り替えを無効化
" このオプションは filetype ごとに設定可能
" "*" は全ての filetype に影響する
let g:precious_enable_switch_CursorMoved = {
\   "*" : 0
\}
let g:precious_enable_switch_CursorMoved_i = {
\   "*" : 0
\}

" insert に入った時にスイッチし、抜けた時に元に戻す
augroup test
    autocmd!
    autocmd InsertEnter * :PreciousSwitch
augroup END
''' # }}}

[[plugins]]
repo = 'mattn/benchvimrc-vim'
on_cmd = 'BenchVimrc'

[[plugins]]
repo = 'junegunn/goyo.vim'
on_cmd = 'Goyo'
hook_add = ''' " {{{
nnoremap <F4> :Goyo<CR>
let g:goyo_width = 80
let g:goyo_height = '60%'
function! s:goyo_enter()
  set scrolloff=999
  Limelight
endfunction

function! s:goyo_leave()
  set scrolloff=3
  Limelight!
endfunction

autocmd! User GoyoEnter nested call <SID>goyo_enter()
autocmd! User GoyoLeave nested call <SID>goyo_leave()
''' # }}}

[[plugins]]
repo = 'junegunn/vim-easy-align'
on_map = '<Plug>(EasyAlign)'
hook_add = '''
vmap ga <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)
'''

[[plugins]]
repo =  'tyru/open-browser.vim'
on_map = {nx = '<Plug>(openbrowser-'}
hook_add ='''
nmap <Leader>o <Plug>(openbrowser-smart-search)
vmap <Leader>o <Plug>(openbrowser-smart-search)
'''

[[plugins]]
repo = 'haya14busa/incsearch-migemo.vim'
depends = 'incsearch.vim'
#TODO:qitta
on_map = { nx = '<Plug>(incsearch-migemo-' }
hook_add = ''' " {{{
map g/ <Plug>(incsearch-migemo-/)
map g? <Plug>(incsearch-migemo-?)
''' # }}}


#[[plugins]]
#repo ='plasticboy/vim-markdown' {{{
#on_ft = ['markdown','md']
#hook_add = '''
#let g:vim_markdown_no_default_key_mappings = 1
#let g:vim_markdown_new_list_item_indent = 4
#let g:vim_markdown_foldint_level = 0
#''' }}}

#[[plugins]]
#repo = 'davidhalter/jedi-vim'
#on_ft = ['python']
#hook_add = '''
#let g:jedi#auto_vim_configuration = 0
#'''

[[plugins]]
repo = 'orokasan/clever-f.vim'
on_map = { nx = '<Plug>(clever-f' }
hook_add = ''' " {{{
let g:clever_f_not_overwrites_standard_mappings = 1
nmap f <Plug>(clever-f-f)
xmap f <Plug>(clever-f-f)
omap f <Plug>(clever-f-f)
nmap F <Plug>(clever-f-F)
xmap F <Plug>(clever-f-F)
omap F <Plug>(clever-f-F)
nmap t <Plug>(clever-f-t)
xmap t <Plug>(clever-f-t)
omap t <Plug>(clever-f-t)
nmap T <Plug>(clever-f-T)
xmap T <Plug>(clever-f-T)
omap T <Plug>(clever-f-T)
let g:clever_f_mark_cursor = 0
let g:clever_f_mark_char_color = "Underlined"
let g:clever_f_hide_cursor_on_cmdline = 0
let g:clever_f_smart_case = 1
let g:clever_f_across_no_line = 1
let g:clever_f_chars_match_any_signs = ':;'
let g:clever_f_use_migemo = 1
let g:clever_f_sings_match_any_signs =
    \ '\[!"#$%&''()=~|\-^\\@`[\]{};:+*<>,.?_/、。「」（）『』！？]'
''' # }}}

[[plugins]]
repo = 'haya14busa/vim-asterisk'
on_map = { nx = '<Plug>(asterisk'}
depends = 'is.vim'
hook_add = ''' "{{{
"let g:asterisk#keeppos = 1
map <silent> *  <Plug>(asterisk-z*)<Plug>(is-nohl-1):<C-u>AnzuUpdateSearchStatus<CR>
map <silent> g* <Plug>(asterisk-gz*)<Plug>(is-nohl-1):<C-u>AnzuUpdateSearchStatus<CR>
map <silent> #  <Plug>(asterisk-z#)<Plug>(is-nohl-1):<C-u>AnzuUpdateSearchStatus<CR>
map <silent> g# <Plug>(asterisk-gz#)<Plug>(is-nohl-1):<C-u>AnzuUpdateSearchStatus<CR>
''' # }}}

[[plugins]]
on_map = { nxi = '<Plug>(easymotion'}
repo = 'easymotion/vim-easymotion'
hook_add = ''' " {{{
let g:EasyMotion_do_mapping = 0
nmap m <Plug>(easymotion-s2)
nmap M <Plug>(easymotion-overwin-f2)
imap <C-z> <ESC><Plug>(easymotion-s2)
xmap m <Plug>(easymotion-s2)
omap m <Plug>(easymotion-s2)
map gj <Plug>(easymotion-sol-j)
map gk <Plug>(easymotion-sol-k)

" Jump to first match with enter & space
let g:EasyMotion_use_upper = 1
let g:EasyMotion_keys = 'ASDFGHJKLQWERTYUIOPZXCVBNM'
let g:EasyMotion_smartcase = 1
let g:EasyMotion_space_jump_first = 1
let g:EasyMotion_use_migemo = 1
let g:EasyMotion_prompt = '{n}>>> '
let g:EasyMotion_verbose = 0
hi link EasyMotionTarget Type
hi link EasyMotionShade  Comment
hi link EasyMotionTarget2First MatchParen
hi link EasyMotionTarget2Second MatchParen
hi link EasyMotionMoveHL Search
hi link EasyMotionIncSearch Search
''' # }}}

[[plugins]]
repo = 'thinca/vim-quickrun'
on_cmd = ['QuickRun']
on_map = { n = '<Plug>(quickrun' }
hook_add = ''' " {{{
nmap <Leader>q <Plug>(quickrun)
let g:quickrun_config = {'_': {}}
let g:quickrun_config = {
    \ "_" : {
        \ "hook/close_unite_quickfix/enable_hook_loaded" : 1,
        \ "hook/unite_quickfix/enable_failure" : 1,
        \ "hook/close_quickfix/enable_exit" : 1,
        \ "hook/close_buffer/enable_failure" : 1,
        \ "hook/close_buffer/enable_empty_data" : 1,
        \ "outputter/buffer/split" : "botright8",
        \ "outputter/buffer/close_on_empty" : 1
    \ }
\ }
let g:quickrun_config['python'] = {
    \ 'command': 'python3'
    \ }
if has('nvim')
  " Use 'neovim_job' in Neovim
  let g:quickrun_config._.runner = 'neovim_job'
elseif exists('*ch_close_in')
  " Use 'job' in Vim which support job feature
  let g:quickrun_config._.runner = 'job'
endif
let g:quickrun_config['tex'] = {
            \   'command' : 'latexmk',
            \   'outputter' : 'error',
            \   'outputter/error/error' : 'quickfix',
            \   'cmdopt': '',
            \   'exec': ['%c %o %s']
            \ }
''' # }}}

[[plugins]]
depends = ['vim-quickrun']
on_source = ['vim-quickrun']
repo = 'lambdalisue/vim-quickrun-neovim-job'

[[plugins]]
repo = 'mbbill/undotree'
#TODO:qitta
on_cmd = ['UndotreeToggle']
hook_add = '''
nnoremap U :<C-u>UndotreeToggle<CR>
let g:undotree_SetFocusWhenToggle = 1
'''

[[plugins]]
repo = 't9md/vim-textmanip'
on_map = { x = '<Plug>(textmanip'}
hook_add = ''' " {{{
xmap <C-j> <Plug>(textmanip-move-down)
xmap <C-k> <Plug>(textmanip-move-up)
xmap <C-h> <Plug>(textmanip-move-left)
xmap <C-l> <Plug>(textmanip-move-right)
" toggle insert/replace with <F10>
" nmap <F10> <Plug>(textmanip-toggle-mode)
" xmap <F10> <Plug>(textmanip-toggle-mode)
''' # }}}

[[plugins]]
repo = 'majutsushi/tagbar'
on_cmd = ['Tagbar']

[[plugins]]
repo = 'cocopon/colorswatch.vim'
on_cmd = ['ColorSwatchGenerate']

[[plugins]]
repo = 'norcalli/nvim-colorizer.lua'
on_cmd = ['ColorizerToggle']

[[plugins]]
on_cmd = ['Clap']
repo = 'liuchengxu/vim-clap'

[[plugins]]
repo = 'voldikss/vim-translate-me'
#TODO:qitta
on_map = { nx = '<Plug>Translate' }
hook_add = '''
  nmap <silent> <Leader>t <Plug>TranslateW
  vmap <silent> <Leader>t <Plug>TranslateWV
  let g:vtm_target_lang = 'ja'
  let g:vtm_default_engines = ['google']
  let g:vtm_default_mapping = 0
'''


# [[plugins]]
# repo = 'deoplete-plugins/deoplete-jedi'
# on_event = 'InsertEnter'
# hook_add = '''
# let g:deoplete#sources#jedi#statement_length = 30
# let g:deoplete#sources#jedi#show_docstring = 1
# '''

# [[plugins]]
# repo = 'raghur/fruzzy'
# on_source = ['denite.nvim']
# hook_source = '''
# let g:fruzzy#usenative = 1
# let g:fruzzy#sortonempty = 1
# '''
# hook_post_update = 'call fruzzy#install()'

# [[plugins]]
# repo = 'lervag/vimtex'
# on_ft = ['tex']
# hook_source = '''
# let g:vimtex_quickfix_open_on_warning = 1
# let g:vimtex_view_method = 'skim'
# let g:tex_flavor = 'latex'
# let g:vimtex_matchparen_enabled = 0
# let g:vimtex_compiler_latexmk = {
#       \ 'options': [
#       \    '-pdfdvi',
#       \],
#       \}

# call deoplete#custom#var('omni', 'input_patterns', {
#     \ 'tex': g:vimtex#re#deoplete
#     \})
# '''

[[plugins]]
repo =  'lambdalisue/gina.vim'
on_cmd = ['Gina']
hook_add = '''
"{{{
nnoremap <Leader>as :<C-u>Gina status --short<CR>
let g:gina#core#spinner#delaytime = 10
'''
hook_source = '''
call gina#custom#command#alias('branch', 'br')
call gina#custom#command#option('br', '-v', 'v')
call gina#custom#command#option(
\ '/\%(log\|reflog\)',
\ '--opener', 'vsplit'
\)
call gina#custom#command#option(
\ '/\%(status\|branch\|ls\|grep\|changes\|tag\)',
\ '--opener' , '10split'
\)
call gina#custom#command#option(
\ 'log', '--group', 'log-viewer'
\)
call gina#custom#command#option(
\ 'status', '--group', 'status-viewer'
\)
call gina#custom#command#option(
\ 'reflog', '--group', 'reflog-viewer'
\)
call gina#custom#command#option(
\ 'commit', '-v|--verbose'
\)
call gina#custom#command#option(
\ 'status', '--short'
\)
call gina#custom#command#option(
\ '/\%(status\|commit\)',
\ '-u|--untracked-files'
\)
"call gina#custom#command#option(
"\ '/\%(status\|changes\)',
"\ '--ignore-submodules'
"\)

"call gina#custom#action#alias(
"\ 'branch', 'track',
"\ 'checkout:track'
"\)
call gina#custom#action#alias(
\ 'branch', 'merge',
\ 'commit:merge'
\)
call gina#custom#action#alias(
\ 'branch', 'rebase',
\ 'commit:rebase'
\)

call gina#custom#mapping#nmap(
\ '/.*', 'q',
\ ':close<CR>',
\ {'noremap': 1, 'silent': 1}
\)
call gina#custom#mapping#nmap(
\ 'diff', 'q',
\ ':bdelete<CR>',
\ {'noremap': 1, 'silent': 1}
\)
"call gina#custom#mapping#nmap(
"\ 'status', '<C-^>',
"\ ':<C-u>Gina commit<CR>',
"\ {'noremap': 1, 'silent': 1}
"\)
"call gina#custom#mapping#nmap(
"\ 'commit', '<C-^>',
"\ ':<C-u>Gina status<CR>',
"\ {'noremap': 1, 'silent': 1}
"\)
''' # }}}

[[plugins]]
repo = 'kana/vim-niceblock'
on_map = {x = '<Plug>'}
hook_add = '''
  xmap I  <Plug>(niceblock-I)
  xmap A  <Plug>(niceblock-A)
'''

[[plugins]]
on_source = ['deoplete.nvim']
repo = 'lighttiger2505/deoplete-vim-lsp'

[[plugins]]
on_ft = 'go'
repo = 'mattn/vim-goimports'

[[plugins]]
repo = 'fatih/vim-go'
on_ft = ['go']
hook_add = '''
let g:go_highlight_functions = 1
let g:go_highlight_function_parameters = 1
let g:go_highlight_types = 1
" let g:go_highlight_fields = 1
" let g:go_highlight_build_constraints = 1
let g:go_highlight_generate_tags = 1
let g:go_highlight_variable_declarations = 1
'''

# vim:set foldmethod=marker:
