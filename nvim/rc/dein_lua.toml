# [[plugins]]
# repo = 'nvim-telescope/telescope.nvim'
# lazy = 1
# on_lua = 'telescope'
# hook_add = '''
# lua <<EOF
# require('telescope').setup{
#   defaults = {
#       border = false,
#     -- Default configuration for telescope goes here:
#     -- config_key = value,
#     -- ..
#   },
#   pickers = {
#     -- Default configuration for builtin pickers goes here:
#     -- picker_name = {
#     --   picker_config_key = value,
#     --   ...
#     -- }
#     -- Now the picker_config_key will be applied every time you call this
#     -- builtin picker
#   },
#   extensions = {
#     -- Your extension configuration goes here:
#     -- extension_name = {
#     --   extension_config_key = value,
#     -- }
#     -- please take a look at the readme of the extension you want to configure
#   }
# }
# EOF
# hi! link TelescopeNormal Pmenu
# '''

# [[plugins]]
# repo = 'nvim-lua/popup.nvim'
# lazy = 1
# on_lua = 'popup'
# [[plugins]]
# repo = 'nvim-lua/plenary.nvim'
# lazy = 1
# on_lua = 'plenary'
# [[plugins]]
# on_lua = 1
# repo ='lewis6991/gitsigns.nvim'
# hook_add = '''
# '''

[[plugins]]
repo = 'lukas-reineke/indent-blankline.nvim'
lazy = 1
on_event = 'BufRead'
hook_add = '''
let g:indentLine_fileTypeExclude = ['defx', 'denite', 'denite-filter','fern', 'help']
let g:indent_blankline_use_treesitter = v:true
let g:indent_blankline_show_first_indent_level = v:true
let g:indent_blankline_char = '|'
let g:indent_blankline_show_current_context = v:true
let g:indent_blankline_context_patterns = ['^if','class', 'function', 'method']
'''

# [[plugins]]
# repo = 'gelguy/wilder.nvim'
# on_lazy = 1
# on_lua = 1
# hook_add = '''
# function! s:wilder_init() abort
# " call wilder#enable_cmdline_enter()
# set wildcharm=<Tab>
# cmap <expr> <Tab> wilder#in_context() ? wilder#next() : "\<Tab>"
# cmap <expr> <S-Tab> wilder#in_context() ? wilder#previous() : "\<S-Tab>"
# cmap <expr> <C-n> wilder#in_context() ? wilder#next() : "\<Down>"
# cmap <expr> <C-p> wilder#in_context() ? wilder#previous() : "\<Up>"

# [[plugins]]
# repo = 'hrsh7th/nvim-compe'
# on_if = 'has("nvim")'
# hook_add = '''
# lua << EOF
# require'compe'.setup {
#   enabled = true;
#   autocomplete = true;
#   debug = false;
#   min_length = 2;
#   preselect = 'enable';
#   throttle_time = 80;
#   source_timeout = 200;
#   incomplete_delay = 400;
#   max_abbr_width = 100;
#   max_kind_width = 100;
#   max_menu_width = 100;
#   documentation = true;
#   source = {
#     path = true;
#     buffer = false;
#     calc = true;
#     nvim_lsp = true;
#     nvim_lua = true;
#     vsnip = true;
#   };
# }
# EOF
# let g:lexima_no_default_rules = v:true
# call lexima#set_default_rules()
# inoremap <silent><expr> <C-Space> compe#complete()
# inoremap <silent><expr> <CR>      compe#confirm(lexima#expand('<LT>CR>', 'i'))
# inoremap <silent><expr> <C-e>     compe#close('<C-e>')
# " inoremap <silent><expr> <C-f>     compe#scroll({ 'delta': +4 })
# inoremap <silent><expr> <C-d>     compe#scroll({ 'delta': -4 })
# " imap <silent><expr> <TAB>
# "       \ pumvisible() ? "\<TAB>" :
# "       \ compe#complete()
# imap <expr> <C-k>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-k>'
# smap <expr> <C-k>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-k>'
# " Expand or jump
# imap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'
# smap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'
# " Jump forward or backward
# " imap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'
# " smap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'
# " imap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'
# " smap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'
# " if exists('g:started_by_firenvim')
# "   set showtabline=0
# "   set laststatus=0
# "   set background=dark
# " augroup Firenvim
# "     au BufEnter * call Set_Font(g:firenvim_font)
# "     au BufEnter *     colorscheme iceberg
# "     " au BufEnter github.com_*.txt set filetype=markdown
# "   " au BufEnter github.com_*.txt set filetype=markdown | call Set_Font(g:firenvim_font)
# "   " au BufEnter play.rust-lang.org_*.txt set filetype=rust | call Set_Font(g:firenvim_font)
# "   " au BufEnter play.golang.org_*.txt set filetype=go |call Set_Font(g:firenvim_font)
# " augroup END
# " endif
# " let g:firenvim_font = 'Cica'
# " function! Set_Font(font) abort
# "   execute 'set guifont=' . a:font . ':h12'
# " endfunction

# set cinwords=if,else,while,do,for,switch

# function! s:get_metadata(...) abort
#   return {
#   \   'priority': 10,
#   \   'menu': '[eskk]',
#   \ }
# endfunction

# function! s:determine(context) abort
#     let a:context.line = nvim_get_current_line()
#     let a:context.before_line = a:context.line[0:a:context.col]
#     let a:context.before_char = a:context.before_line[-1:]
#     echom a:context
#     if !eskk#is_enabled()
#                 \ || eskk#get_preedit().get_henkan_phase() ==#
#                 \             g:eskk#preedit#PHASE_NORMAL
#                 \ || a:context.before_char !~# '\w$'
#         let offset = -1
#     endif
    
#     let offset =  eskk#complete#eskkcomplete(1, '')
#     let p = {
#           \   'keyword_pattern_offset': offset,
#           \   'trigger_character_offset': a:context.before_char ? a:context.col + offset : 0
#           \ }
#     return p
#   " let offset = vim_dadbod_completion#omni(1, '') + 1
#   " let char = a:context.before_char
#   " if offset > 0
#   "   return {
#   "         \   'keyword_pattern_offset': offset,
#   "         \   'trigger_character_offset': char =~? s:trigger_rgx ? a:context.col : 0
#   "         \ }
#   " endif
#   return {}

# endfunction

# function! s:complete(args) abort
#     " echom a:args
#     " let input = s:context.line[a:ke]
# let items = eskk#complete#eskkcomplete(0, a:args.input)
#   " for item in items
#   "   let item.filter_text = item.abbr
#   " endfor
#   call a:args.callback({ 'items': items, 'incomplete': v:true })
# endfunction

# let s:source = {
# \   'get_metadata': function('s:get_metadata'),
# \   'determine': function('s:determine'),
# \   'complete': function('s:complete'),
# \ }

# " Register your custom source.
# call compe#register_source('eskk', s:source)

#   let g:compe = {}
#   let g:compe.enabled = v:true
#   let g:compe.debug = v:true

#   " let g:compe.source = {
#   "   \ 'eskk': v:true,
#   "   \ }

#   let g:compe.source = {
#     \ 'path': v:true,
#     \ 'buffer': v:true,
#     \ 'nvim_lsp': v:true,
#     \ }

# augroup GrepCmd
#     autocmd!
#     autocmd QuickFixCmdPost vim,grep,make if len(getqflist()) != 0 | cwindow | endif
# augroup END
# if executable('rg')
#     let &grepprg = 'rg --vimgrep --hidden'
#     set grepformat=%f:%l:%c:%m
# endif

# command! CompeEnable call s:compe_enable()
# command! CompeDisable call s:compe_disable()
# function! s:compe_enable()
#     call compe#setup({ 'enabled': v:true },0)
# endfunction
# function! s:compe_disable()
#     call compe#setup({ 'enabled': v:false },0)
# endfunction
# '''

[[plugins]]
repo = 'norcalli/nvim-colorizer.lua'
lazy = 1
on_cmd = ['ColorizerToggle']

[[plugins]]
repo = 'bfredl/nvim-miniyank'
# lazy = 1
# on_map = '<Plug>(miniyank'
hook_add = '''
map p <Plug>(miniyank-autoput)
map P <Plug>(miniyank-autoPut)
map <leader>n <Plug>(miniyank-cycle)
map <leader>N <Plug>(miniyank-cycleback)
map <Leader>pc <Plug>(miniyank-tochar)
map <Leader>pl <Plug>(miniyank-toline)
map <Leader>pb <Plug>(miniyank-toblock)
" function! To_miniyank_on_focused() abort
"     let data = {}
"     let data = {
" 		\ 'regcontents': [getreg('*')],
" 		\ 'visual': v:false,
" 		\ 'inclusive': v:false,
" 		\ 'regname': '',
" 		\ 'operator': 'y',
" 		\ 'regtype': 'V',
" 		\ }
"     call miniyank#on_yank(data)
"     echom 'hoge'
" endfunction
" au dein FocusGained * To_miniyank_on_focused()
'''

# [[plugins]]
# repo = 'TimUntersberger/neogit'
# hook_add = '''
# '''
# [[plugins]]
# repo = "sindrets/diffview.nvim"

# [[plugins]]
# repo = 'sunjon/shade.nvim'
# on_event = ['VimEnter']
# hook_source = '''
# lua <<EOF
# require'shade'.setup({
#   overlay_opacity = 70,
#   opacity_step = 1,
#   keys = {
#     brightness_up    = '<C-Up>',
#     brightness_down  = '<C-Down>',
#     toggle           = '<Leader>s',
#   }
# })
# EOF
# '''
# [[plugins]]
# repo = 'kyazdani42/nvim-web-devicons'
# [[plugins]]
# repo = 'windwp/nvim-autopairs'
# hook_add = '''
# '''
# [[plugins]]
# repo = 'dinhhuy258/git.nvim'
# hook_add = '''
# '''

[[plugins]]
on_if = 'executable("gcc")'
lazy = 1
on_event = 'BufRead'
repo = 'nvim-treesitter/nvim-treesitter'
hook_source = '''
lua <<EOF
require'nvim-treesitter.configs'.setup {
    highlight = {
        enable = true,
        disable = { "cpp", "vim" },
    },
}

EOF
'''
#[[plugins]]
##lua script eg.impatient.nvim might cause segfault when alt-tab
#repo = 'lewis6991/impatient.nvim'
#merged = 1
#hook_add = '''
#lua require('impatient')
#'''

# [[plugins]]
# repo = 'nathom/filetype.nvim'
# hook_add = '''
#   " Do not source the default filetype.vim
# '''

# [[plugins]]
# merged = 0
# repo = 'hoob3rt/lualine.nvim'
