[[plugins]]
on_source = ['nvim-lspconfig']
repo = 'williamboman/mason.nvim'

[[plugins]]
repo = 'williamboman/mason-lspconfig.nvim'
on_source = ['nvim-lspconfig']

[[plugins]]
on_event = ['BufRead']
repo = 'neovim/nvim-lspconfig'
# depend = ['mason.nvim', 'mason-lspconfig.nvim']
# plugins = ['mason.nvim', 'mason-lspconfig.nvim', 'nvim-lspconfig']
hook_source = '''
let s:lsptoggle_switch = v:false
command! -nargs=? -complete=command LspToggle call s:lspdefinetoggleaucmd()
function! s:lspdefinetoggleaucmd() abort
    if !s:lsptoggle_switch
        let s:lsptoggle_switch = v:true
        augroup lsptoggle
            au!
            au BufEnter * LspStop
        augroup END
        edit %
        echom "Lsp OFF"
    else
        augroup lsptoggle
            au!
        augroup END
        let s:lsptoggle_switch = v:false
        echom "Lsp ON"
    endif
endfunction
lua << EOF
local vim = vim

local nvim_lsp = require('lspconfig')

require("lsp-inlayhints").setup()
vim.api.nvim_create_augroup("LspAttach_inlayhints", {})
vim.api.nvim_create_autocmd("LspAttach", {
  group = "LspAttach_inlayhints",
  callback = function(args)
    if not (args.data and args.data.client_id) then
      return
    end

    local bufnr = args.buf
    local client = vim.lsp.get_client_by_id(args.data.client_id)
    require("lsp-inlayhints").on_attach(client, bufnr, true)
  end,
})

local on_attach = function(client, bufnr)
  local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end

  local opts = { noremap = true, silent = true }
  buf_set_keymap('n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', opts)
  buf_set_keymap('n', 'gd', '<cmd>lua vim.lsp.buf.definition()<CR>', opts)
  buf_set_keymap('n', 'K', '<cmd>lua vim.lsp.buf.hover()<CR>', opts)
  buf_set_keymap('n', 'gI', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
  buf_set_keymap('n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
  buf_set_keymap('n', '<space>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
  buf_set_keymap('n', '<space>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
  buf_set_keymap('n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
  buf_set_keymap('n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
  buf_set_keymap('n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
  buf_set_keymap('n', 'sc', '<cmd>lua vim.lsp.buf.code_action()<CR>', opts)
  buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references(nil, {on_list=on_list})<CR>', opts)
  buf_set_keymap('n', '<space>we', '<cmd>lua vim.diagnostic.open_float()<CR>', opts)
  buf_set_keymap('n', '[d', '<cmd>lua vim.diagnostic.goto_prev()<CR>', opts)
  buf_set_keymap('n', ']d', '<cmd>lua vim.diagnostic.goto_next()<CR>', opts)
  -- buf_set_keymap('n', '<space>q', '<cmd>lua vim.diagnostic.setloclist()<CR>', opts)
  buf_set_keymap('n', '<space>f', '<cmd>lua vim.lsp.buf.format({async = True})<CR>', opts)

  vim.lsp.handlers["textDocument/hover"] = vim.lsp.with(
    vim.lsp.handlers.hover, {
    -- Use a sharp border with `FloatBorder` highlights
    border = "single"
  })

  vim.cmd([[
         augroup My_group
           autocmd!
         augroup END
       ]])
  -- autocmd CursorHold * lua vim.diagnostic.open_float()
  vim.api.nvim_exec([[
  hi! link DiagnosticError Error
  hi! link DiagnosticWarning Warning
  ]], false)
end

local lspinstaller = require("mason")
lspinstaller.setup {}
local capabilities = vim.lsp.protocol.make_client_capabilities()
capabilities.textDocument.completion.completionItem.snippetSupport = true;


local default_config = {
  on_attach = on_attach,
  capabilities = capabilities,
  root_dir = function(fname)
    return vim.fn.fnamemodify(fname, ':h')
  end
}
local mason_lspconfig = require('mason-lspconfig')
mason_lspconfig.setup({
  automatic_installation = true
})
mason_lspconfig.setup_handlers({ function(server_name)
  local config = default_config

  if server_name == 'denols' then
    config = vim.tbl_extend('force', default_config,
      {
        single_file_support = true,
        init_options = {
          enable = true,
          lint = true,
          unstable = true,
        },
        filetypes = {
          'typescript'
        }
      })
  end
  if server_name == 'marksman' then
    config = vim.tbl_extend('force', default_config,
      {
        init_options = {
          enable = false,
          lint = false,
        },
      })
  end
  if server_name == 'tsserver' then
    config = vim.tbl_extend('force', default_config,
      {
        settings = {
          typescript = {
            format = {
              enable = false,
            },
            validate = false,
            suggest = {
              enabled = false
            },
            preferences = {
              importModuleSpecifierEnding = "minimal",
            },
            inlayHints = {
              includeInlayParameterNameHints = 'all',
              includeInlayParameterNameHintsWhenArgumentMatchesName = false,
              includeInlayFunctionParameterTypeHints = true,
              includeInlayVariableTypeHints = true,
              includeInlayPropertyDeclarationTypeHints = true,
              includeInlayFunctionLikeReturnTypeHints = true,
              includeInlayEnumMemberValueHints = true,
            }
          },
        },
        filetypes = {
          'javascript',
        }
      })

  end
  local root_files = {
    -- Single-module projects
    {
      'build.xml', -- Ant
      'pom.xml', -- Maven
      'settings.gradle', -- Gradle
      'settings.gradle.kts', -- Gradle
    },
    -- Multi-module projects
    { 'build.gradle', 'build.gradle.kts' },
  }

  if server_name == 'jdtls' then
    config = vim.tbl_extend('force', default_config,
      {
        root_dir = function(fname)
          for _, patterns in ipairs(root_files) do
            local root = nvim_lsp.util.root_pattern(unpack(patterns))(fname)
            if root then
              return root
            end
          end
        end
      })
  end

  local root_files = {
    'settings.gradle', -- Gradle (multi-project)
    'settings.gradle.kts', -- Gradle (multi-project)
    'build.xml', -- Ant
    'pom.xml', -- Maven
  }

  local fallback_root_files = {
    'build.gradle', -- Gradle
    'build.gradle.kts', -- Gradle
  }

  if server_name == 'kotlin_language_server' then
    config = vim.tbl_extend('force', default_config,
      {
        get_root_dir = function(fname)
          for _, patterns in ipairs(root_files) do
            local root = nvim_lsp.util.root_pattern(unpack(root_files))(fname) or
                nvim_lsp.util.root_pattern(unpack(fallback_root_files))(fname)
            if root then
              return root
            end
          end
        end
      })
  end

  -- ファイル名に日本語が入ると動かなくなる
  if server_name == 'efm' then
    config = vim.tbl_extend('force', default_config,
      {
        autostart = false,
        debounce_text_changes = 1500,
        get_root_dir = function(fname)
          return vim.fn.fnamemodify(fname, ':h')
        end,
        single_file_support = true,
        filetypes = {
          'markdown',
          'text',
          'txt',
          'json',
          'html',
          'typescript',
          'css',
        }
      })
  end

  if server_name == 'sumneko_lua' then
    config = vim.tbl_extend('force', default_config,
      {
        settings = {
          Lua = {
            runtime = {
              version = 'LuaJIT',
            },
            completion = {
              callSnippet = 'Both',
            },
            diagnostics = {
              globals = { 'vim' },
            },
            workspace = {
              -- Make the server aware of Neovim runtime files
              library = vim.api.nvim_get_runtime_file("", true),
            },
            -- Do not send telemetry data containing a randomized but unique identifier
            telemetry = {
              enable = false,
            },
          },
        }
      })
  end

  nvim_lsp[server_name].setup(
    config
  )
end })
EOF
'''

# [[plugins]]
# repo = 'nvim-lua/popup.nvim'
# on_lua = 'popup'

[[plugins]]
repo = 'nvim-lua/plenary.nvim'
on_lua = ["plenary"]

[[plugins]]
repo = 'lukas-reineke/indent-blankline.nvim'
on_event = ["BufRead"]
hook_add = '''
let g:indentLine_fileTypeExclude = ['defx', 'denite', 'denite-filter','fern', 'help','voomtree','ddu-ff']
let g:indent_blankline_use_treesitter = v:true
"let g:indent_blankline_show_first_indent_level = v:true
let g:indent_blankline_char = '|'
let g:indent_blankline_show_current_context = v:true
let g:indent_blankline_show_current_context_start = v:true
"let g:indent_blankline_context_patterns = ['^if','class', 'function', 'method']
'''
lua_source = '''
require("indent_blankline").setup {
  -- for example, context is off by default, use this to turn it on
  show_current_context = true,
  show_current_context_start = true,
  use_treesitter_scope = true,
}
'''

[[plugins]]
repo = 'norcalli/nvim-colorizer.lua'
on_cmd = ['ColorizerToggle']

[[plugins]]
repo = 'bfredl/nvim-miniyank'
on_map = ['<Plug>(miniyank']
on_event = ["FocusLost"]
hook_add = '''
let g:miniyank_maxitems = 25
map p <Plug>(miniyank-autoput)
map P <Plug>(miniyank-autoPut)
map <leader>n <Plug>(miniyank-cycle)
map <leader>N <Plug>(miniyank-cycleback)
map <Leader>pc <Plug>(miniyank-tochar)
map <Leader>pl <Plug>(miniyank-toline)
map <Leader>pb <Plug>(miniyank-toblock)
function! To_miniyank_on_focused() abort
    let data = {}
    let data = {
		\ 'regcontents': [getreg('*')],
		\ 'visual': v:false,
		\ 'inclusive': v:false,
		\ 'regname': '',
		\ 'operator': 'y',
		\ 'regtype': 'V',
		\ }
    call miniyank#on_yank(data)
endfunction
au dein FocusGained * call To_miniyank_on_focused()
'''

# [[plugins]]
# repo = "sindrets/diffview.nvim"

[[plugins]]
if = 'executable("gcc")'
repo = 'nvim-treesitter/nvim-treesitter'
on_event = ['BufRead']
lua_source = '''
local ts_path = vim.fn.stdpath('data') .. '/treesitter'
vim.api.nvim_set_option('runtimepath', vim.api.nvim_get_option('runtimepath') .. ',' .. ts_path)

require 'nvim-treesitter.configs'.setup {
  parser_install_dir = ts_path,
  tree_docs = { enable = true },
  highlight = {
    enable = true,
    disable = { "cpp", "toml", "help", },
    -- additional_vim_regex_highlighting = {'markdown'},
  },
  indent = {
    enable = true
  },
  incremental_selection = {
    enable = true,
    keymaps = {
      init_selection = "gnn",
      node_incremental = "grn",
      scope_incremental = "grc",
      node_decremental = "grm",
    },
  },
}
'''

# [[plugins]]
# repo = 'nvim-lua/lsp-status.nvim'

[[plugins]]
repo = 'delphinus/hop.nvim'
rev = 'feature/migemo'
on_cmd = ["HopChar2"]
hook_add = '''
nnoremap  sa :HopChar2<CR>
"highlight! clear HopUnmatched
"highlight! HopNextKey1 gui=bold guifg=#ff007c guibg=#c6c8d1
"highlight! HopNextKey2 gui=bold guifg=#2b8db3 guibg=#c6c8d1
"highlight! HopNextKey gui=bold guifg=#ff007c guibg=#c6c8d1
'''
lua_source = '''
require 'hop'.setup {
  use_migemo = true;
  migemo_dict = vim.g.migemo_dict;
  migemo_debug = false;
}
'''

[[plugins]]
repo = 'kevinhwang91/nvim-hlslens'
on_lua = ['hlslens']
lua_source = '''
require('hlslens').setup({
  calm_down = true,
  nearest_only = true,
  nearest_float_when = 'auto',
})
'''
[[plugins]]
on_cmd = ["Linediff"]
repo = 'AndrewRadev/linediff.vim'

[[plugins]]
on_event = ['CmdlineEnter']
repo = 'yutkat/history-ignore.vim'
lua_source = '''
require('history-ignore').setup{}
'''

# [[plugins]]
# repo = 'zsugabubus/crazy8.nvim'

# [[plugins]]
# repo = 'petertriho/nvim-scrollbar'

# [[plugins]]
# repo = 'nvim-treesitter/nvim-tree-docs'
# [[plugins]]
# repo = 'rcarriga/nvim-notify'

# [[plugins]]
# repo = 'nvim-treesitter/nvim-treesitter-context'

[[plugins]]
on_source = ['nvim-lspconfig']
repo = 'lvimuser/lsp-inlayhints.nvim'
# [[plugins]]
# repo = 'mfussenegger/nvim-dap'
# lua_add = '''
# local function map(mode, lhs, rhs, opts)
#   local options = { noremap = true }
#   if opts then options = vim.tbl_extend('force', options, opts) end
#   vim.api.nvim_set_keymap(mode, lhs, rhs, options)
# end

# map("n", "<leader>d", ":lua require'dapui'.toggle()<CR>", { silent = true })
# map("n", "<leader><leader>df", ":lua require'dapui'.eval()<CR>", { silent = true })
# map("n", "<F5>", ":lua require'dap'.continue()<CR>", { silent = true })
# map("n", "<F10>", ":lua require'dap'.step_over()<CR>", { silent = true })
# map("n", "<F11>", ":lua require'dap'.step_into()<CR>", { silent = true })
# map("n", "<F12>", ":lua require'dap'.step_out()<CR>", { silent = true })
# map("n", "<leader>b", ":lua require'dap'.toggle_breakpoint()<CR>", { silent = true })
# map("n", "<leader>bc", ":lua require'dap'.set_breakpoint(vim.fn.input('Breakpoint condition: '))<CR>", { silent = true })
# map("n", "<leader>l", ":lua require'dap'.set_breakpoint(nil, nil, vim.fn.input('Log point message: '))<CR>",
#   { silent = true })
# '''
# [[plugins]]
# repo = 'rcarriga/nvim-dap-ui'

[[plugins]]
repo = 'mfussenegger/nvim-ts-hint-textobject'
on_lua = ['tsht']
hook_add = '''
onoremap <silent> m :<C-U>lua require('tsht').nodes()<CR>
xnoremap <silent> m :lua require('tsht').nodes()<CR>
'''

[[plugins]]
repo = 'David-Kunz/treesitter-unit'
on_lua = ['treesitter-unit']
hook_add = '''
xnoremap iu :lua require"treesitter-unit".select()<CR>
xnoremap au :lua require"treesitter-unit".select(true)<CR>
onoremap iu :<c-u>lua require"treesitter-unit".select()<CR>
onoremap au :<c-u>lua require"treesitter-unit".select(true)<CR>
'''
# [[plugins]]
# repo = 'nvim-treesitter/nvim-treesitter-textobjects'

# [[plugins]]
# repo = 'akinsho/toggleterm.nvim'
# on_cmd = ["ToggleTerm"]
# hook_add = '''
# nnoremap <Space>t <cmd>ToggleTerm<CR>
# nnoremap <Space>T <cmd>ToggleTermSendCurrentLine<CR>
# '''
# lua_source = '''
# require 'toggleterm'.setup {
#   size = function(term)
#     if term.direction == "horizontal" then
#       return 20
#     elseif term.direction == "vertical" then
#       return vim.o.columns * 0.4
#     end
#   end,
#   shade_terminals = true
# }
# '''
# [[plugins]]
# repo = 'levouh/tint.nvim'

[[plugins]]
on_cmd = ["AerialOpen"]
repo = 'stevearc/aerial.nvim'
lua_add = '''
vim.api.nvim_set_keymap('n', '-', '<cmd>AerialOpen<CR>', { noremap = true, silent = true })
-- vim.api.nvim_create_autocmd({ "FileType" }, {
--   pattern = { "markdown" },
--   command = "Aerial!",
--   group = 'vimrc'
-- 
-- })
'''
lua_source = '''
vim.api.nvim_create_autocmd({ "Filetype" }, {
  pattern = { "aerial" },
  command = "setlocal winbar=Outline",
  group = 'vimrc'

})
local aerial = require("aerial")
require('aerial').setup({
  layout = {
    width = 40,
    min_width = 30,
    default_direction = "right",
  },
  show_guides = true,
  -- Customize the characters used when show_guides = true
  lsp = {
    -- Fetch document symbols when LSP diagnostics update.
    -- If false, will update on buffer changes.
    diagnostics_trigger_update = false,

    -- Set to false to not update the symbols when there are LSP errors
    update_when_errors = false,
    -- How long to wait (in ms) after a buffer change before updating
    -- Only used when diagnostics_trigger_update = false
    update_delay = 300,
  },
  guides = {
    -- When the child item has a sibling below it
    mid_item = " ",
    -- When the child item is the last in the list
    last_item = " ",
    -- When there are nested child guides to the right
    nested_top = " ",
    -- Raw indentation
    whitespace = " ",
  },
  txt = {
    update_delay = 300
  },
  backends = {
    ['_']      = { "lsp", "treesitter", "txt" },
    typescript = { "lsp" },
  },
  disable_max_lines = 100000,
  filter_kind = {
    "Class",
    "Type",
    "Constructor",
    "Enum",
    "Function",
    "Interface",
    "Property",
    "Parameter",
    "Module",
    "Method",
    "Struct",
  },
  close_automatic_events = { 'unsupported', 'switch_buffer' },

  open_automatic = function(bufnr)
    return false
    -- Enforce a minimum line count
    -- return vim.api.nvim_buf_line_count(bufnr) > 80
    --   -- Enforce a minimum symbol count
    --   and not aerial.was_closed()
  end
})
'''

[[plugins]]
repo = 'ray-x/lsp_signature.nvim'
on_source = ['nvim-lspconfig']
lua_source = '''
local cfg = {
  debug = false, -- set to true to enable debug logging
  log_path = vim.fn.stdpath("cache") .. "/lsp_signature.log", -- log dir when debug is on
  -- default is  ~/.cache/nvim/lsp_signature.log
  verbose = false, -- show debug line number

  bind = true, -- This is mandatory, otherwise border config won't get registered.
  -- If you want to hook lspsaga or other signature handler, pls set to false
  doc_lines = 10, -- will show two lines of comment/doc(if there are more than two lines in doc, will be truncated);
  -- set to 0 if you DO NOT want any API comments be shown
  -- This setting only take effect in insert mode, it does not affect signature help in normal
  -- mode, 10 by default

  max_height = 12, -- max height of signature floating_window
  max_width = 80, -- max_width of signature floating_window
  wrap = true, -- allow doc/signature text wrap inside floating_window, useful if your lsp return doc/sig is too long

  floating_window = false, -- show hint in a floating window, set to false for virtual text only mode

  floating_window_above_cur_line = false, -- try to place the floating above the current line when possible Note:
  -- will set to true when fully tested, set to false will use whichever side has more space
  -- this setting will be helpful if you do not want the PUM and floating win overlap

  floating_window_off_x = 1, -- adjust float windows x position.
  floating_window_off_y = 0, -- adjust float windows y position. e.g -2 move window up 2 lines; 2 move down 2 lines

  close_timeout = 4000, -- close floating window after ms when laster parameter is entered
  fix_pos = false, -- set to true, the floating window will not auto-close until finish all parameters
  hint_enable = true, -- virtual hint enable
  hint_prefix = "", -- Panda for parameter, NOTE: for the terminal not support emoji, might crash
  hint_scheme = "String",
  hi_parameter = "LspSignatureActiveParameter", -- how your parameter will be highlight
  handler_opts = {
    border = "single" -- double, rounded, single, shadow, none
  },

  always_trigger = false, -- sometime show signature on new line or in middle of parameter can be confusing, set it to false for #58

  auto_close_after = nil, -- autoclose signature float win after x sec, disabled if nil.
  extra_trigger_chars = {}, -- Array of extra characters that will trigger signature completion, e.g., {"(", ","}
  zindex = 200, -- by default it will be on top of all floating windows, set to <= 50 send it to bottom

  padding = '', -- character to pad on left and right of signature can be ' ', or '|'  etc

  transparency = nil, -- disabled by default, allow floating win transparent value 1~100
  shadow_blend = 36, -- if you using shadow as border use this set the opacity
  shadow_guibg = 'Black', -- if you using shadow as border use this set the color e.g. 'Green' or '#121315'
  timer_interval = 200, -- default timer check interval set to lower value if you want to reduce latency
  toggle_key = nil, -- toggle signature on and off in insert mode,  e.g. toggle_key = '<M-x>'

  select_signature_key = nil, -- cycle to next signature, e.g. '<M-n>' function overloading
  move_cursor_key = nil, -- imap, use nvim_set_current_win to move cursor between current win and floating
}

-- recommended:
require 'lsp_signature'.setup(cfg) -- no need to specify bufnr if you don't use toggle_key
'''

[[plugins]]
repo = 'delphinus/cellwidths.nvim'
on_event = ['BufRead']
lua_source = '''
require("cellwidths").setup {
  name = "user/custom",
  -- log_level = 'DEBUG',
  fallback = function(cw)
    -- 特定のテンプレートから追加・削除を行いたい場合は最初に load() を呼んで下さい。
    -- cw.load "default"
    cw.load "default"
    -- 好きな設定を追加します。以下のどの書式でも構いません。
    cw.add {
      { 0x00d7, 0x00d7, 2 },
      { 0x03b1, 0x03c9, 2 },
      { 0x201c, 0x201d, 2 },
      { 0x2015, 0x2015, 2 },
      { 0x2018, 0x2018, 2 },
      { 0x2020, 0x2020, 2 },
      { 0x2024, 0x203f, 2 },
      { 0x2100, 0x2103, 2 },
      { 0x2120, 0x2123, 2 },
      { 0x2160, 0x2169, 2 },
      { 0x2170, 0x2179, 2 },
      { 0x2190, 0x2193, 2 },
      { 0x21d2, 0x21d2, 2 },
      { 0x21d4, 0x21d4, 2 },
      { 0x2212, 0x2212, 2 },
      { 0x2252, 0x2252, 2 },
      { 0x2266, 0x2267, 2 },
      { 0x2460, 0x24ff, 2 },
      { 0x25a0, 0x25a1, 2 },
      { 0x25b2, 0x25b3, 2 },
      { 0x25bc, 0x25bd, 2 },
      { 0x25c6, 0x25c7, 2 },
      { 0x25cb, 0x25cf, 2 },
      { 0x25ef, 0x25ef, 2 },
      { 0x2600, 0x267f, 2 },
      { 0x2690, 0x269c, 2 },
      { 0x26a0, 0x26ad, 2 },
      { 0x26b0, 0x26b1, 2 },
      { 0x26b9, 0x26b9, 2 },
      { 0x2701, 0x2709, 2 },
      { 0x270c, 0x2727, 2 },
      { 0x2729, 0x274d, 2 },
      { 0x274f, 0x2752, 2 },
      { 0x2756, 0x2756, 2 },
      { 0x2758, 0x275e, 2 },
      { 0x2761, 0x2794, 2 },
      { 0x2798, 0x279f, 2 },
      { 0x27f5, 0x27f7, 2 },
      { 0x2b05, 0x2b0d, 2 },
      { 0x303f, 0x303f, 2 },
      { 0xe62e, 0xe62e, 2 },
      { 0xf315, 0xf316, 2 },
      { 0xf31b, 0xf31c, 2 },
      { 0xe0a0, 0xe0a3, 2 },
      { 0xe0b0, 0xe0c8, 2 },
      { 0xe0ca, 0xe0ca, 2 },
      { 0xe0cc, 0xe0d2, 2 },
      { 0xe0d4, 0xe0d4, 2 },
      { 0xe725, 0xe725, 2 },
    }
    -- 削除も出来ます。設定に存在しないコードポイントを指定してもエラーになりません。
    -- cw.delete(0x2103)
  end,
}
'''

[[plugins]]
repo = 'onsails/lspkind.nvim'
on_source = ['aerial.nvim']
lua_source = '''
require('lspkind').init({
  -- DEPRECATED (use mode instead): enables text annotations
  --
  -- default: true
  -- with_text = true,

  -- defines how annotations are shown
  -- default: symbol
  -- options: 'text', 'text_symbol', 'symbol_text', 'symbol'
  mode = 'symbol_text',
  -- default symbol map
  -- can be either 'default' (requires nerd-fonts font) or
  -- 'codicons' for codicon preset (requires vscode-codicons font)
  --
  -- default: 'default'
  preset = 'codicons',
  -- override preset symbols
  --
  -- default: {}
  symbol_map = {
    Text = "",
    Method = "",
    Function = "",
    Constructor = "",
    Field = "ﰠ",
    Variable = "",
    Class = "ﴯ",
    Interface = "",
    Module = "",
    Property = "ﰠ",
    Unit = "塞",
    Value = "",
    Enum = "",
    Keyword = "",
    Snippet = "",
    Color = "",
    File = "",
    Reference = "",
    Folder = "",
    EnumMember = "",
    Constant = "",
    Struct = "פּ",
    Event = "",
    Operator = "",
    TypeParameter = ""
  },
})
'''

[[plugins]]
repo = 'monaqa/dial.nvim'
on_map = ["<Plug>(dial-"]
hook_add = '''
nnoremap  <C-a>  <Plug>(dial-increment)
nnoremap  <C-x>  <Plug>(dial-decrement)
vnoremap  <C-a>  <Plug>(dial-increment)
vnoremap  <C-x>  <Plug>(dial-decrement)
vnoremap g<C-a> g<Plug>(dial-increment)
vnoremap g<C-x> g<Plug>(dial-decrement)
'''
lua_source = '''
local augend = require("dial.augend")
require("dial.config").augends:register_group{
  default = {
    augend.integer.alias.decimal,
--    augend.integer.alias.hex,
--    augend.date.alias["%Y/%m/%d"],
-- augend.date.alias["%Y年%-m月%-d日(%J)"],
--    augend.date.alias["%Y年%-m月%-d日"],
-- augend.constant.alias.ja_weekday,
-- augend.constant.alias.ja_weekday_full,
-- augend.constant.alias.bool,
augend.misc.alias.markdown_header,
augend.constant.new{
    elements = {"[ ]", "[x]"},
    word = false,
    cyclic = true,
    },},
}
'''
# [[plugins]]
# repo = 'kristijanhusak/line-notes.nvim'
# lua_add = '''
# require'line-notes'.setup({
# })
# '''

[[plugins]]
repo = 'lewis6991/gitsigns.nvim'
on_event = ['BufRead']
hook_source = '''
hi! GitsignsAdd guifg=#8a8a67 guibg=#1e2132
hi! GitsignsChange guifg=#54909c guibg=#1e2132
hi! GitSignsDelete guifg=#9c4848 guibg=#1e2132
'''
lua_source = '''
require('gitsigns').setup{
signs = {
    -- add          = { hl = 'GitSignsAdd'   , text = '│', numhl='DiffChange'   , linehl='GitSignsAddLn'    },
    -- change       = { hl = 'GitSignsChange', text = '│', numhl='Identifier', linehl='GitSignsChangeLn' },
    -- delete       = { hl = 'GitSignsDelete', text = '_', numhl='DiffDelete', linehl='GitSignsDeleteLn' },
  },
  signcolumn = false,  -- Toggle with `:Gitsigns toggle_signs`
  numhl      = true, -- Toggle with `:Gitsigns toggle_numhl`
  linehl     = false, -- Toggle with `:Gitsigns toggle_linehl`
  word_diff  = false, -- Toggle with `:Gitsigns toggle_word_diff`
on_attach = function(bufnr)
    local gs = package.loaded.gitsigns

    local function map(mode, l, r, opts)
      opts = opts or {}
      opts.buffer = bufnr
      vim.keymap.set(mode, l, r, opts)
    end

    -- Navigation
    map('n', ']c', function()
      if vim.wo.diff then return ']c' end
      vim.schedule(function() gs.next_hunk() end)
      return '<Ignore>'
    end, {expr=true})

    map('n', '[c', function()
      if vim.wo.diff then return '[c' end
      vim.schedule(function() gs.prev_hunk() end)
      return '<Ignore>'
    end, {expr=true})

    -- Actions
    map({'n', 'v'}, '<leader>xs', ':Gitsigns stage_hunk<CR>')
    map({'n', 'v'}, '<leader>xr', ':Gitsigns reset_hunk<CR>')
    map('n', '<leader>xS', gs.stage_buffer)
    map('n', '<leader>xu', gs.undo_stage_hunk)
    map('n', '<leader>xR', gs.reset_buffer)
    map('n', '<leader>xp', gs.preview_hunk)
    map('n', '<leader>xb', function() gs.blame_line{full=true} end)
    map('n', '<leader>xb', gs.toggle_current_line_blame)
    map('n', '<leader>xd', gs.diffthis)
    map('n', '<leader>xD', function() gs.diffthis('~') end)
    map('n', '<leader>td', gs.toggle_deleted)

    -- Text object
    map({'o', 'x'}, 'ih', ':<C-U>Gitsigns select_hunk<CR>')
  end
}
'''

[[plugins]]
repo = 'Decodetalkers/csv-tools.lua'
on_ft = ['csv', 'tsv']
lua_source = '''
require("csvtools").setup({
    before = 10,
    after = 10,
    clearafter = true,
    -- this will clear the highlight of buf after move
    showoverflow = false,
    -- this will provide a overflow show
    titelflow = true,
    -- add an alone title

})
'''

# [[plugins]]
# lazy = 0
# require = ['promise-async']
# hook_post_update = "lua require('fundo').install()"
# repo = 'kevinhwang91/nvim-fundo'
# lua_add = '''
# require('fundo').setup({
#     opt = {
#         archives_dir = vim.fn.stdpath('data') .. require('fundo.fs.path').sep .. 'fundo'
#     },
# })
# '''

# [[plugins]]
# lazy = 0
# repo = 'kevinhwang91/promise-async'
